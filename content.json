{"meta":{"title":"tenecnt's blog","subtitle":2333,"description":null,"author":"tenecnt","url":"http://tenecnt.github.io"},"pages":[],"posts":[{"title":"后缀自动机","slug":"hzzdj","date":"2018-07-15T18:26:05.000Z","updated":"2018-07-15T18:28:27.521Z","comments":true,"path":"2018/07/16/hzzdj/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/hzzdj/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738char c[MN];int n,tot=0;struct Node&#123; int maxlen,slink,tran[26];&#125;N[MN];int Nd(int _maxlen,int _tran,int _slink)&#123; N[++tot]=(Node)&#123;_maxlen,_slink,0&#125;; if(_tran)&#123; for(int i=0;i&lt;26;++i)if(N[_tran].tran[i])N[tot].tran[i]=N[_tran].tran[i];else N[tot].tran[i]=0; &#125;else for(int i=0;i&lt;26;++i)N[tot].tran[i]=0; return tot;&#125;int addchar(char cc,int u)&#123; int ch=cc-'a'; int z=Nd(N[u].maxlen+1,0,0); int v=u; while(v&amp;&amp;!N[v].tran[ch])&#123; N[v].tran[ch]=z; v=N[v].slink; &#125; if(!v)&#123;N[z].slink=1;return z;&#125; int x=N[v].tran[ch]; if(N[v].maxlen==N[x].maxlen-1)&#123; N[z].slink=x; return z; &#125; int y=Nd(N[v].maxlen+1,x,N[x].slink); N[x].slink=y;N[z].slink=y; while(v&amp;&amp;N[v].tran[ch]==x)&#123; N[v].tran[ch]=y; v=N[v].slink; &#125;return z;&#125;void insert()&#123; Nd(0,0,0); int now=1; for(int i=1;i&lt;=n;++i)&#123;now=addchar(c[i],now);&#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://tenecnt.github.io/tags/字符串/"}]},{"title":"虚树","slug":"xushu","date":"2018-07-15T18:21:10.000Z","updated":"2018-07-15T18:25:33.145Z","comments":true,"path":"2018/07/16/xushu/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/xushu/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 600005#define pil pair&lt;int,long long&gt;#define mp make_pair#define ft first#define sd second#define lg long longint n,m,K,q;int nex[MN],fr[MN],vi[MN];lg wi[MN];int tote;int tail=0,stk[MN];void add(int x,int y,lg z)&#123; nex[++tote]=fr[x];fr[x]=tote;wi[tote]=z;vi[tote]=y;&#125;int dfc=0,dfn[MN];int dep[MN],f[20][MN];lg g[20][MN];void dfs(int x,int fa)&#123; dfn[x]=++dfc;for(int i=1;i&lt;=19;++i)f[i][x]=f[i-1][f[i-1][x]],g[i][x]=min(g[i-1][x],g[i-1][f[i-1][x]]); for(int i=fr[x];i;i=nex[i])if(vi[i]!=fa)&#123; f[0][vi[i]]=x;g[0][vi[i]]=wi[i];dep[vi[i]]=dep[x]+1;dfs(vi[i],x); &#125;&#125;pil Lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); if(x==y)return mp(x,0); lg res=0x3f3f3f3f3f3f3f3f; for(int i=19;~i;--i)&#123; if(dep[f[i][x]]&gt;=dep[y])&#123; res=min(res,g[i][x]); x=f[i][x]; &#125; &#125;if(x==y) return mp(x,res); for(int i=19;~i;--i)&#123; if(f[i][x]!=f[i][y])&#123; res=min(res,min(g[i][x],g[i][y])); x=f[i][x];y=f[i][y]; &#125; &#125; return mp(f[0][x],min(res,min(g[0][x],g[0][y])));&#125;int v[MN],dd[MN];int Fr[MN],Nex[MN],Vi[MN];lg Wi[MN];int Tot=0;queue&lt;int&gt; Q;void Add(int x,int y,lg z)&#123;Nex[++Tot]=Fr[x];Wi[Tot]=z;Fr[x]=Tot;Vi[Tot]=y;Nex[++Tot]=Fr[y];Wi[Tot]=z;Fr[y]=Tot;Vi[Tot]=x;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;lg dfs2(int x,int fa)&#123; lg ans=0; // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;fa&lt;&lt;endl; for(int i=Fr[x];i;i=Nex[i])if(Vi[i]!=fa)&#123; // cout&lt;&lt;Vi[i]&lt;&lt;endl; if(dd[Vi[i]])ans+=Wi[i];else ans+=min(Wi[i],dfs2(Vi[i],x)); &#125;return ans;&#125;void bt()&#123; sort(v+1,v+m+1,cmp);Tot=0;pil L;tail=0; for(int i=0;i&lt;=m;++i)dd[v[i]]=1; // cout&lt;&lt;\"&amp;\"&lt;&lt;endl; for(int i=0;i&lt;=m;++i)&#123; // cout&lt;&lt;i&lt;&lt;endl; if(i&amp;&amp;v[i]==v[i-1])continue; // cout&lt;&lt;v[i]&lt;&lt;' '&lt;&lt;v[i-1]&lt;&lt;endl; L=Lca(stk[tail],v[i]);; while(tail&gt;1)&#123; if(dep[L.ft]&gt;dep[stk[tail]]||L.ft==stk[tail])break; // cout&lt;&lt;stk[tail]&lt;&lt;' '&lt;&lt;stk[tail-1]&lt;&lt;' '&lt;&lt;Lca(stk[tail],stk[tail-1]).sd&lt;&lt;\"&amp;&amp;&amp;\"&lt;&lt;endl; Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd); --tail; &#125; if(L.ft!=stk[tail])Fr[L.ft]=0,stk[++tail]=L.ft,Q.push(L.ft); for(int i=0;i&lt;=m;++i)dd[v[i]]=0; Fr[v[i]]=0;stk[++tail]=v[i];Q.push(v[i]); &#125; // cout&lt;&lt;\"@\"&lt;&lt;endl; while(tail!=1)Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd),--tail; printf(\"%lld\\n\",dfs2(1,1)); while(!Q.empty())&#123;int x=Q.front();Q.pop();dd[x]=0;&#125; // cout&lt;&lt;\"^\"&lt;&lt;endl;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;++i)&#123; lg z; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); &#125;dep[1]=1;dfs(1,1); scanf(\"%d\",&amp;q);v[0]=1; while(q--)&#123; // cout&lt;&lt;\"$\"&lt;&lt;endl; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;++i)scanf(\"%d\",v+i); bt(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"}]},{"title":"Helloworld","slug":"Helloworld","date":"2018-07-14T00:19:15.000Z","updated":"2018-07-16T04:45:10.272Z","comments":true,"path":"2018/07/14/Helloworld/","link":"","permalink":"http://tenecnt.github.io/2018/07/14/Helloworld/","excerpt":"","text":"第二次转移博客$ \\sqrt{\\phi} $ {1+1=2}{\\fac 1}Simple inline $a = b + c$ \\frac{\\partial u}{\\partial t} = h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)","categories":[],"tags":[{"name":"试验","slug":"试验","permalink":"http://tenecnt.github.io/tags/试验/"},{"name":"math","slug":"math","permalink":"http://tenecnt.github.io/tags/math/"}]}]}
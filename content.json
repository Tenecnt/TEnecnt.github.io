{"meta":{"title":"tenecnt's blog","subtitle":2333,"description":null,"author":"tenecnt","url":"http://tenecnt.github.io"},"pages":[],"posts":[{"title":"NOI2018冒泡排序(inverse)","slug":"noi18b","date":"2018-07-19T12:22:44.000Z","updated":"2018-07-19T23:28:07.949Z","comments":true,"path":"2018/07/19/noi18b/","link":"","permalink":"http://tenecnt.github.io/2018/07/19/noi18b/","excerpt":"","text":"首先，根据那个啥的定义，首先必须得到坏序列的充要条件是 \\exists{i a_{k} 证明就感性理解一下，对于中间那个数，无论它目标位置是在左边还是右边，都有至少一步向反方向移动，所以一定是坏序列了 80 然后80分就很简单了，设计这么一个函数，$F_{i,j}$表示目前有i个数需要排列，但是由于前面的数的限制，最小的$j$个数的相对顺序必须递增。 容易得到递推式： F_{i,j} = \\sum^{j-1}_{i} F_{i-1,k} 其实就是枚举拿的是哪个数，最小数就是$F_{i-1,k}$,否则对应了各个数。 然后就拿这个东西像数位dp一样扫一遍过去就是O($n^2$)了 100 满分算法就比较神仙了 曾经有这样一道题 为了解决在一条直线限制下A点走到B点的方案数，这里用到了一种高妙的方法，将起点按对称线翻转计数，这里的每一种方案刚好一一对应了一种原起点到终点的一种路线(想象将该路线第一次遇到对称轴前的路径翻折)，于是这样，就能解决上述的小问题。 那么，对于这个问题，我们可以发现，在dp转移的时候，其实对应了一个长度为2n的括号序列。 每次转移对应了在原串后面加上了若干左括号和一个右括号（当取的是最小数时对应0个左括号+1个右括号） 然后将左括号和右括号转化成在二维坐标上的两个向右上（下）45度的向量，所以这就成了一个在二维上自由行走（但不能低于x轴）的问题，同时必须满足中途没有低于过一条线（除非已经高于过这条直线）。 于是想80分一样，对于每一位统计在这位超过限制的答案数，这里可以发现，只要先多出现了一个左括号，后面的左括号都能在自由行走中补充，所以每位的统计可以O(1)，这就使总体复杂度化为O(n)了 可是我为了偷懒，没有维护目前比最大值小的值数，用树状数组，多了一个log 能过就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define lg long long#define MN 1200005#define lsk 998244353#define lb(x) ((x)&amp;(-(x)))int n;int a[MN&gt;&gt;1],c[MN&gt;&gt;1],D[MN&gt;&gt;1];int read()&#123; static int d;static char c; for(d=0,c=getchar();c&lt;'0'||c&gt;'9';c=getchar()); for(;c&gt;='0'&amp;&amp;c&lt;='9';d=(d&lt;&lt;3)+(d&lt;&lt;1)+c-'0',c=getchar()); return d;&#125;void add(int x,int y)&#123; for(;x&lt;=n;x+=lb(x))c[x]+=y;&#125;int qry(int x)&#123; int res=0; for(;x;x-=lb(x))res+=c[x]; return res;&#125;lg fac[MN],ifac[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void init()&#123; fac[0]=ifac[0]=1; for(int i=1;i&lt;MN;++i)&#123; fac[i]=fac[i-1]*i%lsk; ifac[i]=Pow(fac[i],lsk-2); &#125;&#125;lg C(int A,int B)&#123; return fac[A]*ifac[B]%lsk*ifac[A-B]%lsk;&#125;lg Q(int A,int B)&#123; return C(A,(A+B)/2);&#125;lg T(int A,int B)&#123; if(B&lt;0)return 0; return ((Q(A,B)-Q(A,B+2))%lsk+lsk)%lsk;&#125;int main()&#123; int TT;init(); scanf(\"%d\",&amp;TT); while(TT--)&#123; memset(D,0,sizeof D); memset(c,0,sizeof c); scanf(\"%d\",&amp;n);lg res=0; for(int i=1;i&lt;=n;++i)add(i,1); for(int i=1;i&lt;=n;++i)a[i]=read(); int mx=0,mn=1; for(int i=1;i&lt;n;++i)&#123; int g=max(mx,a[i]); int f=qry(g)+1; int d=n*2-(i-1)*2-f; res=(res+T(d,f))%lsk; D[a[i]]=1;add(a[i],-1); if(a[i]&gt;mx)mx=a[i]; else&#123; if(a[i]!=mn)break; &#125; while(D[mn])++mn; &#125; printf(\"%lld\\n\",res); &#125; return 0;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://tenecnt.github.io/tags/NOI/"},{"name":"组合数学","slug":"组合数学","permalink":"http://tenecnt.github.io/tags/组合数学/"}]},{"title":"NOI2018归程(return)","slug":"noi18a","date":"2018-07-18T23:30:38.000Z","updated":"2018-07-19T23:41:38.805Z","comments":true,"path":"2018/07/19/noi18a/","link":"","permalink":"http://tenecnt.github.io/2018/07/19/noi18a/","excerpt":"","text":"题面 在同步赛中，时间都花在T2上了，导致这题没怎么想，看到暴力+离线有75就马上打了，没有任何向标算上的思考，当然，可持久化并查集还是想到的，但是写…… 不过话说回来，写log^2的可持久化并查集的都过了…… 不过，标算是个神奇的东西，叫： 克鲁斯卡尔重构树～～其实这是个很蠢的东西～～大家都会克鲁斯卡尔最小生成树吧 只要在建树的时候，为新加的边新建一个点，并把别的两个点连它的儿子 这样，若干次的联通块就是若干子树了，只要倍增维护子树最小值就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define MN 800005#define lg long long#define pli pair&lt;lg,int&gt;#define mp make_pair#define ft first#define sd secondint n,m;int read()&#123; int d=0,f=1;char c=getchar(); while(c&gt;'9'||c&lt;'0')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;d=d*10+c-'0';c=getchar();&#125; return d*f;&#125;int nex[MN],tot=0,vi[MN],fr[MN],ai[MN];lg wi[MN];void add(int x,int y,lg z,int a)&#123; nex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;ai[tot]=a;&#125;struct Ege&#123; int x,y,a;lg c;&#125;E[MN];bool operator&lt;(Ege A,Ege B)&#123; return A.a&lt;B.a;&#125;struct Qry&#123; int v,p,id;&#125;Q[MN];bool operator&lt;(Qry A,Qry B)&#123; return A.p&lt;B.p;&#125;priority_queue&lt;pli,vector&lt;pli &gt;,greater&lt;pli &gt; &gt; pQ;lg ds[MN];int vis[MN],F[MN];lg V[MN];int L[MN];void djk()&#123; memset(ds,0x3f,sizeof ds); memset(vis,0,sizeof vis); ds[1]=0; while(!pQ.empty())pQ.pop(); pQ.push(mp(0,1)); while(!pQ.empty())&#123; int x=pQ.top().sd;pQ.pop(); if(vis[x])continue;vis[x]=1; for(int i=fr[x];i;i=nex[i])&#123; if(ds[x]+wi[i]&lt;ds[vi[i]])&#123; ds[vi[i]]=ds[x]+wi[i]; pQ.push(mp(ds[vi[i]],vi[i])); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)F[i]=i,V[i]=ds[i],L[i]=0x7f7f7f7f;&#125;int gf(int x)&#123; return F[x]==x?x:F[x]=gf(F[x]);&#125;lg res[MN];int f[20][MN];lg Lasans,Ans=0;void clean()&#123; tot=0;memset(fr,0,sizeof fr);Lasans=0;&#125;void un(int x,int y,int v)&#123; f[0][x]=++n; f[0][y]=n; V[n]=min(V[x],V[y]); L[n]=v; F[x]=F[y]=n;F[n]=n;&#125;void bt()&#123; sort(E+1,E+m+1); for(int i=m;i;--i)&#123; int fx=gf(E[i].x),fy=gf(E[i].y); if(fx!=fy)un(fx,fy,E[i].a); &#125; for(int i=1;i&lt;=19;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125;&#125;int main()&#123; int T=read(); while(T--)&#123; clean(); n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; int a=read(),b=read();lg c=read(),d=read(); add(a,b,c,d);add(b,a,c,d);E[i]=(Ege)&#123;a,b,d,c&#125;; &#125;int nn=n; djk();Lasans=0;bt(); int q=read(),K=read(),S=read(); for(int i=1;i&lt;=q;++i)&#123; int v=(read()+K*Lasans-1)%nn+1, p=(read()+K*Lasans)%(S+1); for(int j=19;~j;--j)if(L[f[j][v]]&gt;p)v=f[j][v]; Lasans=V[v]; printf(\"%lld\\n\",Lasans); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"},{"name":"NOI","slug":"NOI","permalink":"http://tenecnt.github.io/tags/NOI/"},{"name":"生成树","slug":"生成树","permalink":"http://tenecnt.github.io/tags/生成树/"}]},{"title":"多项式（2）","slug":"poly2","date":"2018-07-17T10:15:28.000Z","updated":"2018-07-17T12:04:05.244Z","comments":true,"path":"2018/07/17/poly2/","link":"","permalink":"http://tenecnt.github.io/2018/07/17/poly2/","excerpt":"","text":"船新版本的多项式！加入了 1) 开根 只有开根…… 不过这样一道6合一模板题(帕秋莉的超级多项式)还是少见的 卡常卡常卡常卡常 突然开了几个register就过了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN],Tmpsqrt[MN],Tmpsqrt2[MN];lg F[MN],G[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFTinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=wn*w%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d!=1)&#123; Inv(y,res,d+1&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFTinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;else&#123; res[0]=Pow(y[0],lsk-2); return; &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125;y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFTinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d!=1)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,d+1&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125;++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFTinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;else&#123; res[0]=1; return; &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Sqrt(lg *y,lg *res,int d)&#123; if(d!=1)&#123; int l=1&lt;&lt;((int)ceil(log2(1&lt;&lt;d))); Sqrt(y,res,(d+1)&gt;&gt;1); fill(Tmpsqrt,Tmpsqrt+l,0); Inv(res,Tmpsqrt,d); fill(Tmpsqrt+d,Tmpsqrt+l,0); copy(y,y+d,Tmpsqrt2); fill(Tmpsqrt2+d,Tmpsqrt2+l,0); FFTinit(l); dft(Tmpsqrt,l);dft(Tmpsqrt2,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]+Tmpsqrt[i]*Tmpsqrt2[i]%lsk; if(res[i]&gt;=lsk)res[i]-=lsk; &#125; idft(res,l); for(int i=0;i&lt;d;++i)&#123; res[i]=res[i]*inv[2]%lsk; &#125; fill(res+d,res+l,0); &#125;else&#123; res[0]=(lg)(sqrt(y[0])); &#125;&#125;void init()&#123; pw[0]=inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; &#125;&#125;int main()&#123; freopen(\"polynomial.in\",\"r\",stdin); freopen(\"polynomial.out\",\"w\",stdout); lg k; scanf(\"%d%lld\",&amp;n,&amp;k); init(); for(int i=0;i&lt;n;++i)scanf(\"%lld\",F+i); int l=1&lt;&lt;((int)ceil(log2(1&lt;&lt;n)));// Inv(F,G,n); Sqrt(F,G,n); //for(int i=0;i&lt;n;++i)printf(\"%lld \",G[i]); fill(F,F+l,0); Inv(G,F,n); fill(G,G+l,0); Int(F,n); Exp(F,G,n); fill(F,F+l,0); Inv(G,F,n);++F[0]; fill(G,G+l,0); Ln(F,G,n);++G[0]; fill(F,F+l,0); Pow(G,F,n,k); Der(F,n); for(int i=0;i&lt;n;++i)printf(\"%lld \",F[i]); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"my todolist和重要网站","slug":"todolist","date":"2018-07-16T05:09:41.000Z","updated":"2018-07-20T12:05:41.497Z","comments":true,"path":"2018/07/16/todolist/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/todolist/","excerpt":"","text":"完成 内容 分治线段树 agc补题 NOI18D1T3 $ \\checkmark $ NOI18D1T2 $ \\checkmark $ 弦图最大团 $ \\checkmark $ dsu on tree 网站：谷歌代码规范","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://tenecnt.github.io/tags/规划/"}]},{"title":"多项式(1)","slug":"poly","date":"2018-07-16T04:46:48.000Z","updated":"2018-07-19T23:53:19.461Z","comments":true,"path":"2018/07/16/poly/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/poly/","excerpt":"","text":"学习了一发多项式，感觉码风得到改善 包括了： 求逆 exp 求导 积分 ln pow 水果沙拉(CodeChef) 基本思路就是将k次方多项式展开，对每一项单独计算，可以推导出是若干以e为幂的数的和的乘积，然后就是多项式了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN],Ex[MN],Iex[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN];lg F[MN],G[MN],Res[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFtinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=w*wn%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=Pow(y[0],lsk-2); return; &#125;else&#123; Inv(y,res,(d+1)&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFtinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125; y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFtinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=1; return; &#125;else&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,(d+1)&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125; ++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFtinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Func(lg u,lg *res)&#123; Tmpfuc[1]=u+1; Tmpfuc[0]=0; int l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); fill(res,res+l,0); Exp(Tmpfuc,res,k+2); for(int i=0;i&lt;=k;++i)res[i]=res[i+1]; res[k+1]=0; fill(res+k+1,res+l,0); FFtinit(l); dft(res,l); for(int i=0;i&lt;=l;++i)&#123; res[i]=res[i]*Iex[i]%lsk; &#125; idft(res,l); fill(res+k+1,res+l,0); fill(Tmpfuc,Tmpfuc+l,0);&#125;void init()&#123; l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); pw[0]=1;inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; assert(inv[i]); &#125; Ex[0]=1; for(int i=1;i&lt;=k;++i)&#123; Ex[i]=Ex[i-1]*inv[i+1]%lsk; &#125; Inv(Ex,Iex,k+1); FFtinit(l); dft(Iex,l);&#125;int main()&#123; scanf(\"%d%*d%d\",&amp;k,&amp;n); init(); fill(Res,Res+l,0);Res[0]=1; for(int i=1;i&lt;=n;++i)&#123; lg a,b;int c; scanf(\"%lld%lld%d\",&amp;a,&amp;b,&amp;c); fill(G,G+k+1,0); fill(F,F+k+1,0); Func(b,G);Func(a-1,F); for(int j=0;j&lt;=k;++j)&#123; G[j]-=F[j]; if(G[j]&lt;0)G[j]+=lsk; &#125; fill(F,F+k+1,0); Pow(G,F,k+1,c); FFtinit(l); dft(Res,l);dft(F,l); for(int j=0;j&lt;l;++j)&#123; Res[j]=Res[j]*F[j]%lsk; &#125; idft(Res,l); fill(Res+k+1,Res+l,0); &#125; lg res=1; for(int i=2;i&lt;=k;++i)res=res*i%lsk; printf(\"%lld\",res*Res[k]%lsk); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"后缀自动机","slug":"hzzdj","date":"2018-07-15T18:26:05.000Z","updated":"2018-07-16T05:06:16.656Z","comments":true,"path":"2018/07/16/hzzdj/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/hzzdj/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738char c[MN];int n,tot=0;struct Node&#123; int maxlen,slink,tran[26];&#125;N[MN];int Nd(int _maxlen,int _tran,int _slink)&#123; N[++tot]=(Node)&#123;_maxlen,_slink,0&#125;; if(_tran)&#123; for(int i=0;i&lt;26;++i)if(N[_tran].tran[i])N[tot].tran[i]=N[_tran].tran[i];else N[tot].tran[i]=0; &#125;else for(int i=0;i&lt;26;++i)N[tot].tran[i]=0; return tot;&#125;int addchar(char cc,int u)&#123; int ch=cc-'a'; int z=Nd(N[u].maxlen+1,0,0); int v=u; while(v&amp;&amp;!N[v].tran[ch])&#123; N[v].tran[ch]=z; v=N[v].slink; &#125; if(!v)&#123;N[z].slink=1;return z;&#125; int x=N[v].tran[ch]; if(N[v].maxlen==N[x].maxlen-1)&#123; N[z].slink=x; return z; &#125; int y=Nd(N[v].maxlen+1,x,N[x].slink); N[x].slink=y;N[z].slink=y; while(v&amp;&amp;N[v].tran[ch]==x)&#123; N[v].tran[ch]=y; v=N[v].slink; &#125;return z;&#125;void insert()&#123; Nd(0,0,0); int now=1; for(int i=1;i&lt;=n;++i)&#123;now=addchar(c[i],now);&#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://tenecnt.github.io/tags/字符串/"}]},{"title":"虚树","slug":"xushu","date":"2018-07-15T18:21:10.000Z","updated":"2018-07-16T05:09:00.120Z","comments":true,"path":"2018/07/16/xushu/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/xushu/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 600005#define pil pair&lt;int,long long&gt;#define mp make_pair#define ft first#define sd second#define lg long longint n,m,K,q;int nex[MN],fr[MN],vi[MN];lg wi[MN];int tote;int tail=0,stk[MN];void add(int x,int y,lg z)&#123; nex[++tote]=fr[x];fr[x]=tote;wi[tote]=z;vi[tote]=y;&#125;int dfc=0,dfn[MN];int dep[MN],f[20][MN];lg g[20][MN];void dfs(int x,int fa)&#123; dfn[x]=++dfc;for(int i=1;i&lt;=19;++i)f[i][x]=f[i-1][f[i-1][x]],g[i][x]=min(g[i-1][x],g[i-1][f[i-1][x]]); for(int i=fr[x];i;i=nex[i])if(vi[i]!=fa)&#123; f[0][vi[i]]=x;g[0][vi[i]]=wi[i];dep[vi[i]]=dep[x]+1;dfs(vi[i],x); &#125;&#125;pil Lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); if(x==y)return mp(x,0); lg res=0x3f3f3f3f3f3f3f3f; for(int i=19;~i;--i)&#123; if(dep[f[i][x]]&gt;=dep[y])&#123; res=min(res,g[i][x]); x=f[i][x]; &#125; &#125;if(x==y) return mp(x,res); for(int i=19;~i;--i)&#123; if(f[i][x]!=f[i][y])&#123; res=min(res,min(g[i][x],g[i][y])); x=f[i][x];y=f[i][y]; &#125; &#125; return mp(f[0][x],min(res,min(g[0][x],g[0][y])));&#125;int v[MN],dd[MN];int Fr[MN],Nex[MN],Vi[MN];lg Wi[MN];int Tot=0;queue&lt;int&gt; Q;void Add(int x,int y,lg z)&#123;Nex[++Tot]=Fr[x];Wi[Tot]=z;Fr[x]=Tot;Vi[Tot]=y;Nex[++Tot]=Fr[y];Wi[Tot]=z;Fr[y]=Tot;Vi[Tot]=x;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;lg dfs2(int x,int fa)&#123; lg ans=0; // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;fa&lt;&lt;endl; for(int i=Fr[x];i;i=Nex[i])if(Vi[i]!=fa)&#123; // cout&lt;&lt;Vi[i]&lt;&lt;endl; if(dd[Vi[i]])ans+=Wi[i];else ans+=min(Wi[i],dfs2(Vi[i],x)); &#125;return ans;&#125;void bt()&#123; sort(v+1,v+m+1,cmp);Tot=0;pil L;tail=0; for(int i=0;i&lt;=m;++i)dd[v[i]]=1; // cout&lt;&lt;\"&amp;\"&lt;&lt;endl; for(int i=0;i&lt;=m;++i)&#123; // cout&lt;&lt;i&lt;&lt;endl; if(i&amp;&amp;v[i]==v[i-1])continue; // cout&lt;&lt;v[i]&lt;&lt;' '&lt;&lt;v[i-1]&lt;&lt;endl; L=Lca(stk[tail],v[i]);; while(tail&gt;1)&#123; if(dep[L.ft]&gt;dep[stk[tail]]||L.ft==stk[tail])break; // cout&lt;&lt;stk[tail]&lt;&lt;' '&lt;&lt;stk[tail-1]&lt;&lt;' '&lt;&lt;Lca(stk[tail],stk[tail-1]).sd&lt;&lt;\"&amp;&amp;&amp;\"&lt;&lt;endl; Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd); --tail; &#125; if(L.ft!=stk[tail])Fr[L.ft]=0,stk[++tail]=L.ft,Q.push(L.ft); for(int i=0;i&lt;=m;++i)dd[v[i]]=0; Fr[v[i]]=0;stk[++tail]=v[i];Q.push(v[i]); &#125; // cout&lt;&lt;\"@\"&lt;&lt;endl; while(tail!=1)Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd),--tail; printf(\"%lld\\n\",dfs2(1,1)); while(!Q.empty())&#123;int x=Q.front();Q.pop();dd[x]=0;&#125; // cout&lt;&lt;\"^\"&lt;&lt;endl;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;++i)&#123; lg z; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); &#125;dep[1]=1;dfs(1,1); scanf(\"%d\",&amp;q);v[0]=1; while(q--)&#123; // cout&lt;&lt;\"$\"&lt;&lt;endl; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;++i)scanf(\"%d\",v+i); bt(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"}]},{"title":"Helloworld","slug":"Helloworld","date":"2018-07-14T00:19:15.000Z","updated":"2018-07-19T12:04:22.353Z","comments":true,"path":"2018/07/14/Helloworld/","link":"","permalink":"http://tenecnt.github.io/2018/07/14/Helloworld/","excerpt":"","text":"第二次转移博客$ \\sqrt{\\phi} $ {1+1=2}{\\fac 1}Simple inline $a = b + c$ \\frac{\\partial u}{\\partial t} = h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)","categories":[],"tags":[{"name":"试验","slug":"试验","permalink":"http://tenecnt.github.io/tags/试验/"},{"name":"math","slug":"math","permalink":"http://tenecnt.github.io/tags/math/"}]}]}
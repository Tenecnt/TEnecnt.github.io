{"meta":{"title":"tenecnt's blog","subtitle":2333,"description":null,"author":"tenecnt","url":"http://tenecnt.github.io"},"pages":[],"posts":[{"title":"Min_25筛","slug":"min25s","date":"2018-07-27T12:35:50.000Z","updated":"2018-07-28T00:57:11.837Z","comments":true,"path":"2018/07/27/min25s/","link":"","permalink":"http://tenecnt.github.io/2018/07/27/min25s/","excerpt":"","text":"这个东西续了我好长时间，并且让我意识到状态真的不太对 Min_25筛这个东西，感觉对于不同题，思路上还是有些不同的，只是大致方向一致，所以也没有很多具体模板这种东西吧 大致思路是这样的：首先，处理的内容大致就是积性函数或者什么类似积性函数的奇怪东西前缀和，复杂度大概是什么O(n^{0.69})(这个的证明真的不会) 我们假设如此一个问题： f(n) = \\begin{cases} 1& if\\;n = 1\\\\ g(p,e)& if\\;n = y^e,\\;e > 0,\\;p\\;is\\;a\\;prime \\\\ f(x)*f(y) & if\\;x*y=n,\\;x\\perp y \\\\ \\end{cases}然后求S(N)=\\displaystyle\\sum_{1 \\leqslant j \\leqslant N} f(j) 考虑到一个数除以其最大质因数后一定不剩大于\\sqrt{N}的质因数，这是我们解决这个问题的关键。 考虑枚举因数M: \\begin{aligned} & M' = M/P^{e}\\;,e>0\\\\ & P\\;is\\;the\\;max\\;prime\\;factor\\;of\\;M \\end{aligned}根据这是个积性函数，可知： \\begin{aligned}& f(N)=\\sum_{M'} f(M')*(1+\\sum_{F < p \\leqslant N/M'} f(p))\\\\& F\\;is\\;the\\;largrst\\;prime\\;factor\\;of\\;M'\\;and\\;p\\;is\\;a\\;prime \\end{aligned}(这只是个大致的式子，不完全对，细节可能有问题，可能需要调整) 那么f(M')可以递归解决，问题在于求\\sum_{F < p \\leqslant N/M'} f(p)(自此以下p都为质数) 首先，设h(x)=\\sum_{p \\leqslant x} f(p)，将其转化为h(N/M')-h(F-1) 那么解决了h(x)的求解就能解决问题了 对此如何处理呢？ 首先，如果p不止是质数的话(将合数看做质数处理)，大部分的前缀和都能O(1)求出 例如\\sigma(n^k)(n的k次的因子数) 然后考虑筛的实现 我们回想有什么筛是大家熟知的 埃拉托色尼筛？ 考虑像埃拉托色尼筛一样搞 埃拉托色尼筛怎么搞的？ 每个数p用来筛大于p^2的所有数 所以这里也是这样：从小到大枚举每个质数，用其对大于其平方的数的前缀和进行处理 (这里注意，要处理h(x)的数仅有O(\\sqrt{N})个，为1,2,3,...,N/3,N/2,N/1) 这样就能完美筛出h(x)了 有这么几道具体题目： spoj-DIVCNTK这题就是求f(n)=\\displaystyle\\sum_{1 \\leqslant i \\leqslant n}\\sigma(i^k) 这里首先去掉1这个因数，就成了积性函数。 而f(p)=k的前缀和可以轻松求出。 直接上就好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 4000005#define lg unsigned long longint pri[MN],totp=0,S;bool vd[MN];lg ns[MN],tns=0,h[MN];lg n,k;int D(lg X)&#123; return X&lt;=S?X:tns-n/X+1;&#125;lg f(lg n,int g)&#123;//递归求解f,f(n,g)☞n以内不包括大于pri[g]的质因数的数 if(n&lt;1||pri[g+1]&gt;n)return 0; lg res=h[D(n)]-g*(k+1); while(1ll*pri[g+1]*pri[g+1]&lt;=n)&#123; int p=pri[g+1]; lg t=n/p,e=k+1; while(t&gt;=p)res+=f(t,g+1)*e+e+k,e+=k,t/=p; ++g; &#125;return res;&#125;lg slv(lg n)&#123; S=sqrt(n);//处理h(x) tns=0; for(int i=1;i&lt;=S;++i)&#123; ns[++tns]=i; &#125; for(int i=S;i;--i)&#123; if(n/i&gt;S)ns[++tns]=n/i; &#125; for(int i=1;i&lt;=tns;++i)&#123; h[i]=(ns[i]-1)*(k+1); &#125; int H=1;lg up=0; for(int P=1;pri[P]&lt;=S;++P)&#123; int p=pri[P]; while(ns[H]&lt;1ll*p*p)++H; for(int i=tns;i&gt;=H;--i)&#123; h[i]-=h[D(ns[i]/p)]-up; &#125;up+=k+1; &#125; return f(n,0)+1;&#125;void init()&#123; for(int i=2;i&lt;MN;++i)&#123; if(vd[i])continue; pri[++totp]=i; for(int j=i+i;j&lt;MN;j+=i)vd[j]=1; &#125;&#125;int main()&#123; init();int Cas; for(scanf(\"%d\",&amp;Cas);Cas;--Cas)&#123; scanf(\"%llu%llu\",&amp;n,&amp;k); printf(\"%llu\\n\",slv(n)); &#125; return 0;&#125; APS2这题求的是最小质因数前缀和 考虑枚举最小质因数，要乘的就是最小质因数大于等于与n的数的个数 这个就可以用Min_25筛搞了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 4000005#define ulg unsigned long longint pri[MN],totp=0,S;ulg tp[MN];bool vd[MN];ulg ns[MN],tns=0,h[MN],d[MN];ulg n;int D(ulg X)&#123; return X&lt;=S?X:tns-n/X+1;&#125;ulg c(ulg n,int g)&#123; if(n&lt;1||pri[g]&gt;n)&#123; return 0; &#125; ulg res=d[D(n)]-d[D(pri[g]-1)]; while(1ll*pri[g]*pri[g]&lt;=n)&#123; ulg t=n/pri[g]; while(t&gt;=pri[g])&#123; res+=c(t,g+1); ++res; t/=pri[g]; &#125;++g; &#125; return res;&#125;ulg f(ulg n,int g)&#123; if(n&lt;1||pri[g]&gt;n)return 0; ulg res=h[D(n)]; while(1ll*pri[g]*pri[g]&lt;=n)&#123; ulg t=n/pri[g]; res+=c(t,g)*pri[g]; ++g; &#125;return res;&#125;ulg slv(ulg n)&#123; S=sqrt(n);tns=0; for(int i=1;i&lt;=S;++i)&#123; ns[++tns]=i; &#125; for(int i=S;i;--i)&#123; if(n/i&gt;S)ns[++tns]=n/i; &#125; for(int i=1;i&lt;=tns;++i)&#123; if(!(ns[i]&amp;1))h[i]=(ns[i]+2)/2*(ns[i]-1); else h[i]=(ns[i]-1)/2*(ns[i]+2); d[i]=ns[i]-1; &#125; int H=1; for(int p=2;p&lt;=S;++p)if(!vd[p])&#123; while(ns[H]&lt;1ll*p*p)++H; for(int i=tns;i&gt;=H;--i)&#123; h[i]-=(h[D(ns[i]/p)]-h[p-1])*p; d[i]-=(d[D(ns[i]/p)]-d[p-1]); &#125; &#125; return f(n,1);&#125;void init()&#123; for(int i=2;i&lt;MN;++i)&#123; if(vd[i])continue; pri[++totp]=i; for(int j=i+i;j&lt;MN;j+=i)vd[j]=1; &#125; for(int i=2;i&lt;MN;++i)tp[i]=pri[i]+tp[i-1];&#125;int main()&#123; init();int Cas; for(scanf(\"%d\",&amp;Cas);Cas;--Cas)&#123; scanf(\"%lld\",&amp;n); printf(\"%llu\\n\",slv(n)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://tenecnt.github.io/tags/数论/"},{"name":"数论筛","slug":"数论筛","permalink":"http://tenecnt.github.io/tags/数论筛/"}]},{"title":"Stirling学习","slug":"Stirling","date":"2018-07-24T13:28:44.000Z","updated":"2018-07-29T00:58:50.517Z","comments":true,"path":"2018/07/24/Stirling/","link":"","permalink":"http://tenecnt.github.io/2018/07/24/Stirling/","excerpt":"","text":"昨天学习了一发Stirling数哒哒哒，感觉很有用 首先，Stirling数哒哒哒分两类 第一类Stirling数\\begin{bmatrix} n \\\\ k \\end{bmatrix}这表示第一类Stirling数哒哒哒 意义由 n 个数构成置换的方案数 递推式\\begin{bmatrix} n \\\\ k \\end{bmatrix} = \\begin{bmatrix} n-1 \\\\ k-1 \\end{bmatrix} + (n-1)\\begin{bmatrix} n-1 \\\\ k \\end{bmatrix}解释很简单，对于新加的n,要么单独成一个置换，要么放在某个的后面 用途x^{\\overline{n}} = \\sum_{k}\\begin{bmatrix} n \\\\ k \\end{bmatrix}x^{k}x^{\\underline{n}} = \\sum_{k}\\begin{bmatrix} n \\\\ k \\end{bmatrix}(-1)^{n-k}x^{k}第二类Stirling数\\begin{Bmatrix} n \\\\ k \\end{Bmatrix}这表示第二类Stirling数哒哒哒 意义由 n 个数构成集合的方案数 递推式\\begin{Bmatrix} n \\\\ k \\end{Bmatrix} = \\begin{Bmatrix} n-1 \\\\ k-1 \\end{Bmatrix} + k\\begin{Bmatrix} n-1 \\\\ k \\end{Bmatrix}解释很简单，对于新加的n,要么单独成一个置换，要么放在某个的后面 用途x^{n} = \\sum_{k}\\begin{Bmatrix} n \\\\ k \\end{Bmatrix}x^{\\underline{k}}x^{n} = \\sum_{k}\\begin{Bmatrix} n \\\\ k \\end{Bmatrix}(-1)^{n-k}x^{\\overline{k}}","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://tenecnt.github.io/tags/组合数学/"}]},{"title":"(CC JulyLong)Tom and Jerry","slug":"CCJulyTom","date":"2018-07-24T11:54:37.000Z","updated":"2018-07-24T14:22:59.809Z","comments":true,"path":"2018/07/24/CCJulyTom/","link":"","permalink":"http://tenecnt.github.io/2018/07/24/CCJulyTom/","excerpt":"","text":"这道题首先先猜一个结论：这是要求最大团 但是最大团怎么跑200000呢 这里有一个优越的性质：这是一个弦图 弦图有一个优秀的性质：它有一个完美消除序列 完美消除序列是一个序列，其中每一项在所有往后的项构成的图中都是关键点 还有一个性质：它的最大团大小就是他的最大染色数 还有一个性质：按逆完美消除序列操作贪心染色就是最优解 所以求出完美消除序列就行了 于是要用一个神奇的算法，它叫MCS 它倒过来求完美消除序列 每次取与现在已被取的点中度数最大的 弄一堆链表(vector)就能操作了 以上所有内容，全部只会用不会证。证明？不存在的～～留下一个好东西1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 400005int fr[MN],nex[MN&lt;&lt;1],vi[MN&lt;&lt;1],tot=0;void add(int x,int y)&#123; nex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;&#125;int n,m;int vd[MN],d[MN];struct Node&#123; int v,id;&#125;;bool operator&lt;(Node A,Node B)&#123; return A.v&lt;B.v||A.v==B.v&amp;&amp;A.id&lt;B.id;&#125;vector&lt;int&gt; V[MN];void clear()&#123; memset(fr,0,sizeof fr); tot=0; memset(vd,0,sizeof vd); memset(d,0,sizeof d); for(int i=0;i&lt;=n;++i)V[i].clear();&#125;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--)&#123; clear(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1,a,b;i&lt;=m;++i)&#123; scanf(\"%d%d\",&amp;a,&amp;b); add(a,b);add(b,a); &#125; for(int i=1;i&lt;=n;++i)&#123; V[0].push_back(i); &#125;int Ms=0;int res=0; for(int i=1;i&lt;=n;++i)&#123; while(V[Ms].size()==0||vd[V[Ms][V[Ms].size()-1]])&#123; if(V[Ms].size()==0)--Ms; else V[Ms].pop_back(); &#125; int x=V[Ms][V[Ms].size()-1],sz=1; V[Ms].pop_back(); vd[x]=1; //cout&lt;&lt;x&lt;&lt;\"#\"&lt;&lt;endl; for(int i=fr[x];i;i=nex[i])if(!vd[vi[i]])&#123; ++d[vi[i]]; V[d[vi[i]]].push_back(vi[i]); Ms=max(Ms,d[vi[i]]); //Q.push((Node)&#123;d[vi[i]],vi[i]&#125;); &#125;else ++sz; res=max(res,sz); //cout&lt;&lt;sz&lt;&lt;endl; &#125; printf(\"%d\\n\",res); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"},{"name":"最大团","slug":"最大团","permalink":"http://tenecnt.github.io/tags/最大团/"}]},{"title":"bzoj5170(Fable)","slug":"bzoj5170","date":"2018-07-24T10:57:35.000Z","updated":"2018-07-24T11:53:12.369Z","comments":true,"path":"2018/07/24/bzoj5170/","link":"","permalink":"http://tenecnt.github.io/2018/07/24/bzoj5170/","excerpt":"","text":"QwQ有点有趣 明显，平衡树可以秒这道题 但是总是感觉太烦了。 有没有好一点的方法呢？ 如果我们考虑每一个数，如果没有向后送，向前移的位置数等于前面比它大的数，显然这可以用树状数组搞。 而剩下的数相对顺序一定排好了 所以把剩下的数sort一下填进去就好了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 200005#define lb(x) ((x)&amp;(-x))#define ft first#define sd second#define pii pair&lt;int,int&gt;int c[MN],res[MN],b[MN],n,k;pii a[MN];int add(int x,int y)&#123; for(;x&lt;=n;x+=lb(x))c[x]+=y;&#125;bool C(pii A,pii B)&#123; return A.sd&lt;B.sd;&#125;int qry(int x)&#123; int res=0; for(;x;x-=lb(x))res+=c[x]; return res;&#125;priority_queue&lt;int&gt; pQ;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1;i&lt;=n;++i)&#123; scanf(\"%d\",&amp;a[i].ft); a[i].sd=i; &#125; sort(a+1,a+n+1); for(int i=n;i;--i)&#123; b[a[i].sd]=qry(a[i].sd); add(a[i].sd,1); if(b[a[i].sd]&gt;k)res[a[i].sd-k]=a[i].ft; else pQ.push(a[i].ft); &#125; for(int i=n;i;--i)&#123; if(!res[i])res[i]=pQ.top(),pQ.pop(); &#125; for(int i=1;i&lt;=n;++i)printf(\"%d\\n\",res[i]); return 0;&#125;","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://tenecnt.github.io/tags/树状数组/"}]},{"title":"NOI2018屠龙勇士(dragon)","slug":"noi18d","date":"2018-07-22T11:51:21.000Z","updated":"2018-07-22T13:52:41.605Z","comments":true,"path":"2018/07/22/noi18d/","link":"","permalink":"http://tenecnt.github.io/2018/07/22/noi18d/","excerpt":"","text":"好吧这道题其实是道CRT裸题…… 首先哪条龙选哪把剑是固定的。拿个set(multiset)/map扫一遍即可。当然也可以自己写平衡树啊2333 然后就是若干 k_{i}x \\equiv a_i (mod\\;p_i) 可以讲整个柿子中的k_i,a_i,p_i同除gcd(k_i,p_i)(如果a_i无法整除就无解了)，这肯定对答案是无影响的。然后，江柿子两边同除k_i(已经有逆元了)，变为n个形为x \\equiv a_i/k_i(mod\\;p_i)的柿子这就成了裸的CRT了。对于一个CRT， \\begin{equation} \\begin{cases} x \\equiv a_1(mod\\;p_1) \\\\ x \\equiv a_2(mod\\;p_2) \\\\ gcd(p_1,p_2) = d \\end{cases} \\end{equation}可得 x \\equiv p_1*(a_2-a_1)*(p_1/d)^{-1}/d+a_1(mod\\;n_1n_2/d)于是扫一遍就能A了。注意爆long long，要写慢速乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 200005#define ft first#define sd secondlg a[MN],p[MN],k[MN],ne[MN];int n,m;lg Ep1,Ep2,G,Q;map&lt;lg,int&gt; M;map&lt;lg,int&gt;::iterator it;lg gcd(lg A,lg B)&#123; return B==0?A:gcd(B,A%B);&#125;void exgcd(lg x,lg y,lg&amp; a,lg&amp; b)&#123; if(y==0)a=1,b=0; else exgcd(y,x%y,b,a),b-=x/y*a;&#125;lg inv(lg x,lg y)&#123; lg A,B; exgcd(x,y,A,B); return (A%y+y)%y;&#125;lg Qx(lg x,lg y,lg md)&#123; lg res=0,f=1; if(x&lt;0)x=-x,f=-f; if(y&lt;0)y=-y,f=-f; for(;y;y&gt;&gt;=1,x=(x+x)%md)if(y&amp;1)res=(res+x)%md; res*=f;res%=md;res+=md;res%=md; return res;&#125;lg work()&#123; lg F=1; for(int i=1;i&lt;=n;++i)&#123; int H=gcd(k[i],p[i]); if(a[i]%H)return -1; k[i]/=H,p[i]/=H,a[i]/=H; &#125; //for(int i=1;i&lt;=n;++i)cout&lt;&lt;k[i]&lt;&lt;endl; for(int i=1;i&lt;=n;++i)&#123; F=max(F,(a[i]-1)/k[i]+1); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]-=F*k[i]; a[i]%=p[i]; a[i]+=p[i]; a[i]%=p[i]; &#125; if(G==1)&#123; return F; &#125; for(int i=1;i&lt;=n;++i)&#123; lg H=gcd(k[i],p[i]); a[i]=Qx(a[i],inv(k[i],p[i]),p[i]); &#125; lg np=p[1],na=a[1]; for(int i=2;i&lt;=n;++i)&#123; lg E=gcd(np,p[i]),HH=p[i]/E,QQ=HH*np; //assert(QQ&gt;=0); if((a[i]-na)%E)return -2; exgcd(np,p[i],Ep1,Ep2); Ep1=Qx(Ep1,(a[i]-na)/E,HH); na+=Qx(np,Ep1,QQ); na%=QQ; np=QQ; &#125; return F+na;&#125;int main()&#123; freopen(\"dragon.in\",\"r\",stdin); freopen(\"dragon.out\",\"w\",stdout); int T; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d%d\",&amp;n,&amp;m);M.clear();G=1; for(int i=1;i&lt;=n;++i)scanf(\"%lld\",a+i); for(int i=1;i&lt;=n;++i)&#123; scanf(\"%lld\",p+i); G*=(p[i]==1); &#125; for(int i=1;i&lt;=n;++i)scanf(\"%lld\",ne+i); for(int i=1,b;i&lt;=m;++i)&#123; scanf(\"%d\",&amp;b); ++M[b]; &#125; for(int i=1;i&lt;=n;++i)&#123; if((M.begin()-&gt;ft)&gt;a[i])&#123; k[i]=M.begin()-&gt;ft; --M[M.begin()-&gt;ft]; if((M.begin()-&gt;sd)==0)M.erase(M.begin()); &#125;else&#123; ++M[a[i]]; it=M.find(a[i]); if((it-&gt;sd)&gt;1)&#123; M[a[i]]-=2; k[i]=a[i]; it=M.find(a[i]); if(it-&gt;sd==0)M.erase(it); ++M[ne[i]]; continue; &#125; if((it-&gt;sd)==1)--it; --M[a[i]]; k[i]=it-&gt;ft; --M[it-&gt;ft]; if((it-&gt;sd)==0)M.erase(it); it=M.find(a[i]); if(it-&gt;sd==0)M.erase(it); &#125; ++M[ne[i]]; &#125; printf(\"%lld\\n\",work()); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://tenecnt.github.io/tags/数论/"},{"name":"CRT","slug":"CRT","permalink":"http://tenecnt.github.io/tags/CRT/"}]},{"title":"NOI2018冒泡排序(inverse)","slug":"noi18b","date":"2018-07-19T12:22:44.000Z","updated":"2018-07-22T13:49:56.761Z","comments":true,"path":"2018/07/19/noi18b/","link":"","permalink":"http://tenecnt.github.io/2018/07/19/noi18b/","excerpt":"","text":"这道题的冒泡排序好像是假的 首先，根据那个啥的定义，首先必须得到坏序列的充要条件是 \\exists\\;{i a_{k}证明就感性理解一下，对于中间那个数，无论它目标位置是在左边还是右边，都有至少一步向反方向移动，所以一定是坏序列了 80 然后80分就很简单了，设计这么一个函数，F_{i,j}表示目前有i个数需要排列，但是由于前面的数的限制，最小的$j$个数的相对顺序必须递增。 容易得到递推式： F_{i,j} = \\sum^{j-1}_{k=i} F_{i-1,k}其实就是枚举拿的是哪个数，最小数就是F_{i-1,k},否则对应了各个数。 然后就拿这个东西像数位dp一样扫一遍过去就是O(n^2)了 100 满分算法就比较神仙了 曾经有这样一道题 为了解决在一条直线限制下A点走到B点的方案数，这里用到了一种高妙的方法，将起点按对称线翻转计数，这里的每一种方案刚好一一对应了一种原起点到终点的一种路线(想象将该路线第一次遇到对称轴前的路径翻折)，于是这样，就能解决上述的小问题。 那么，对于这个问题，我们可以发现，在dp转移的时候，其实对应了一个长度为2n的括号序列。 每次转移对应了在原串后面加上了若干左括号和一个右括号（当取的是最小数时对应0个左括号+1个右括号） 然后将左括号和右括号转化成在二维坐标上的两个向右上（下）45度的向量，所以这就成了一个在二维上自由行走（但不能低于x轴）的问题，同时必须满足中途没有低于过一条线（除非已经高于过这条直线）。 于是想80分一样，对于每一位统计在这位超过限制的答案数，这里可以发现，只要先多出现了一个左括号，后面的左括号都能在自由行走中补充，所以每位的统计可以O(1)，这就使总体复杂度化为O(n)了 可是我为了偷懒，没有维护目前比最大值小的值数，用树状数组，多了一个log 能过就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define lg long long#define MN 1200005#define lsk 998244353#define lb(x) ((x)&amp;(-(x)))int n;int a[MN&gt;&gt;1],c[MN&gt;&gt;1],D[MN&gt;&gt;1];int read()&#123; static int d;static char c; for(d=0,c=getchar();c&lt;'0'||c&gt;'9';c=getchar()); for(;c&gt;='0'&amp;&amp;c&lt;='9';d=(d&lt;&lt;3)+(d&lt;&lt;1)+c-'0',c=getchar()); return d;&#125;void add(int x,int y)&#123; for(;x&lt;=n;x+=lb(x))c[x]+=y;&#125;int qry(int x)&#123; int res=0; for(;x;x-=lb(x))res+=c[x]; return res;&#125;lg fac[MN],ifac[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void init()&#123; fac[0]=ifac[0]=1; for(int i=1;i&lt;MN;++i)&#123; fac[i]=fac[i-1]*i%lsk; ifac[i]=Pow(fac[i],lsk-2); &#125;&#125;lg C(int A,int B)&#123; return fac[A]*ifac[B]%lsk*ifac[A-B]%lsk;&#125;lg Q(int A,int B)&#123; return C(A,(A+B)/2);&#125;lg T(int A,int B)&#123; if(B&lt;0)return 0; return ((Q(A,B)-Q(A,B+2))%lsk+lsk)%lsk;&#125;int main()&#123; int TT;init(); scanf(\"%d\",&amp;TT); while(TT--)&#123; memset(D,0,sizeof D); memset(c,0,sizeof c); scanf(\"%d\",&amp;n);lg res=0; for(int i=1;i&lt;=n;++i)add(i,1); for(int i=1;i&lt;=n;++i)a[i]=read(); int mx=0,mn=1; for(int i=1;i&lt;n;++i)&#123; int g=max(mx,a[i]); int f=qry(g)+1; int d=n*2-(i-1)*2-f; res=(res+T(d,f))%lsk; D[a[i]]=1;add(a[i],-1); if(a[i]&gt;mx)mx=a[i]; else&#123; if(a[i]!=mn)break; &#125; while(D[mn])++mn; &#125; printf(\"%lld\\n\",res); &#125; return 0;&#125;","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://tenecnt.github.io/tags/组合数学/"},{"name":"NOI","slug":"NOI","permalink":"http://tenecnt.github.io/tags/NOI/"}]},{"title":"NOI2018归程(return)","slug":"noi18a","date":"2018-07-18T23:30:38.000Z","updated":"2018-07-19T23:41:38.805Z","comments":true,"path":"2018/07/19/noi18a/","link":"","permalink":"http://tenecnt.github.io/2018/07/19/noi18a/","excerpt":"","text":"题面 在同步赛中，时间都花在T2上了，导致这题没怎么想，看到暴力+离线有75就马上打了，没有任何向标算上的思考，当然，可持久化并查集还是想到的，但是写…… 不过话说回来，写log^2的可持久化并查集的都过了…… 不过，标算是个神奇的东西，叫： 克鲁斯卡尔重构树～～其实这是个很蠢的东西～～大家都会克鲁斯卡尔最小生成树吧 只要在建树的时候，为新加的边新建一个点，并把别的两个点连它的儿子 这样，若干次的联通块就是若干子树了，只要倍增维护子树最小值就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define MN 800005#define lg long long#define pli pair&lt;lg,int&gt;#define mp make_pair#define ft first#define sd secondint n,m;int read()&#123; int d=0,f=1;char c=getchar(); while(c&gt;'9'||c&lt;'0')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;d=d*10+c-'0';c=getchar();&#125; return d*f;&#125;int nex[MN],tot=0,vi[MN],fr[MN],ai[MN];lg wi[MN];void add(int x,int y,lg z,int a)&#123; nex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;ai[tot]=a;&#125;struct Ege&#123; int x,y,a;lg c;&#125;E[MN];bool operator&lt;(Ege A,Ege B)&#123; return A.a&lt;B.a;&#125;struct Qry&#123; int v,p,id;&#125;Q[MN];bool operator&lt;(Qry A,Qry B)&#123; return A.p&lt;B.p;&#125;priority_queue&lt;pli,vector&lt;pli &gt;,greater&lt;pli &gt; &gt; pQ;lg ds[MN];int vis[MN],F[MN];lg V[MN];int L[MN];void djk()&#123; memset(ds,0x3f,sizeof ds); memset(vis,0,sizeof vis); ds[1]=0; while(!pQ.empty())pQ.pop(); pQ.push(mp(0,1)); while(!pQ.empty())&#123; int x=pQ.top().sd;pQ.pop(); if(vis[x])continue;vis[x]=1; for(int i=fr[x];i;i=nex[i])&#123; if(ds[x]+wi[i]&lt;ds[vi[i]])&#123; ds[vi[i]]=ds[x]+wi[i]; pQ.push(mp(ds[vi[i]],vi[i])); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)F[i]=i,V[i]=ds[i],L[i]=0x7f7f7f7f;&#125;int gf(int x)&#123; return F[x]==x?x:F[x]=gf(F[x]);&#125;lg res[MN];int f[20][MN];lg Lasans,Ans=0;void clean()&#123; tot=0;memset(fr,0,sizeof fr);Lasans=0;&#125;void un(int x,int y,int v)&#123; f[0][x]=++n; f[0][y]=n; V[n]=min(V[x],V[y]); L[n]=v; F[x]=F[y]=n;F[n]=n;&#125;void bt()&#123; sort(E+1,E+m+1); for(int i=m;i;--i)&#123; int fx=gf(E[i].x),fy=gf(E[i].y); if(fx!=fy)un(fx,fy,E[i].a); &#125; for(int i=1;i&lt;=19;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125;&#125;int main()&#123; int T=read(); while(T--)&#123; clean(); n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; int a=read(),b=read();lg c=read(),d=read(); add(a,b,c,d);add(b,a,c,d);E[i]=(Ege)&#123;a,b,d,c&#125;; &#125;int nn=n; djk();Lasans=0;bt(); int q=read(),K=read(),S=read(); for(int i=1;i&lt;=q;++i)&#123; int v=(read()+K*Lasans-1)%nn+1, p=(read()+K*Lasans)%(S+1); for(int j=19;~j;--j)if(L[f[j][v]]&gt;p)v=f[j][v]; Lasans=V[v]; printf(\"%lld\\n\",Lasans); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"},{"name":"NOI","slug":"NOI","permalink":"http://tenecnt.github.io/tags/NOI/"},{"name":"生成树","slug":"生成树","permalink":"http://tenecnt.github.io/tags/生成树/"}]},{"title":"多项式（2）","slug":"poly2","date":"2018-07-17T10:15:28.000Z","updated":"2018-07-24T10:10:36.717Z","comments":true,"path":"2018/07/17/poly2/","link":"","permalink":"http://tenecnt.github.io/2018/07/17/poly2/","excerpt":"","text":"船新版本的多项式！加入了 1) 开根 只有开根…… 不过这样一道6合一模板题(帕秋莉的超级多项式)还是少见的 卡常卡常卡常卡常 突然开了几个register就过了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN],Tmpsqrt[MN],Tmpsqrt2[MN];lg F[MN],G[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFTinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=wn*w%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d!=1)&#123; Inv(y,res,d+1&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFTinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;else&#123; res[0]=Pow(y[0],lsk-2); return; &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125;y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFTinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d!=1)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,d+1&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125;++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFTinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;else&#123; res[0]=1; return; &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Sqrt(lg *y,lg *res,int d)&#123; if(d!=1)&#123; int l=1&lt;&lt;((int)ceil(log2(1&lt;&lt;d))); Sqrt(y,res,(d+1)&gt;&gt;1); fill(Tmpsqrt,Tmpsqrt+l,0); Inv(res,Tmpsqrt,d); fill(Tmpsqrt+d,Tmpsqrt+l,0); copy(y,y+d,Tmpsqrt2); fill(Tmpsqrt2+d,Tmpsqrt2+l,0); FFTinit(l); dft(Tmpsqrt,l);dft(Tmpsqrt2,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]+Tmpsqrt[i]*Tmpsqrt2[i]%lsk; if(res[i]&gt;=lsk)res[i]-=lsk; &#125; idft(res,l); for(int i=0;i&lt;d;++i)&#123; res[i]=res[i]*inv[2]%lsk; &#125; fill(res+d,res+l,0); &#125;else&#123; res[0]=(lg)(sqrt(y[0])); &#125;&#125;void init()&#123; pw[0]=inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; &#125;&#125;int main()&#123; freopen(\"polynomial.in\",\"r\",stdin); freopen(\"polynomial.out\",\"w\",stdout); lg k; scanf(\"%d%lld\",&amp;n,&amp;k); init(); for(int i=0;i&lt;n;++i)scanf(\"%lld\",F+i); int l=1&lt;&lt;((int)ceil(log2(1&lt;&lt;n))); Sqrt(F,G,n); //for(int i=0;i&lt;n;++i)printf(\"%lld \",G[i]); fill(F,F+l,0); Inv(G,F,n); fill(G,G+l,0); Int(F,n); Exp(F,G,n); fill(F,F+l,0); Inv(G,F,n);++F[0]; fill(G,G+l,0); Ln(F,G,n);++G[0]; fill(F,F+l,0); Pow(G,F,n,k); Der(F,n); for(int i=0;i&lt;n;++i)printf(\"%lld \",F[i]); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"My Todolist和重要网站","slug":"todolist","date":"2018-07-16T05:09:41.000Z","updated":"2018-07-20T12:27:31.789Z","comments":true,"path":"2018/07/16/todolist/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/todolist/","excerpt":"","text":"完成 内容 分治线段树 agc补题 NOI18D1T3 \\checkmark NOI18D1T2 \\checkmark 弦图最大团 \\checkmark dsu on tree 网站：谷歌代码规范","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://tenecnt.github.io/tags/规划/"}]},{"title":"多项式(1)","slug":"poly","date":"2018-07-16T04:46:48.000Z","updated":"2018-07-19T23:53:19.461Z","comments":true,"path":"2018/07/16/poly/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/poly/","excerpt":"","text":"学习了一发多项式，感觉码风得到改善 包括了： 求逆 exp 求导 积分 ln pow 水果沙拉(CodeChef) 基本思路就是将k次方多项式展开，对每一项单独计算，可以推导出是若干以e为幂的数的和的乘积，然后就是多项式了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN],Ex[MN],Iex[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN];lg F[MN],G[MN],Res[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFtinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=w*wn%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=Pow(y[0],lsk-2); return; &#125;else&#123; Inv(y,res,(d+1)&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFtinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125; y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFtinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=1; return; &#125;else&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,(d+1)&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125; ++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFtinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Func(lg u,lg *res)&#123; Tmpfuc[1]=u+1; Tmpfuc[0]=0; int l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); fill(res,res+l,0); Exp(Tmpfuc,res,k+2); for(int i=0;i&lt;=k;++i)res[i]=res[i+1]; res[k+1]=0; fill(res+k+1,res+l,0); FFtinit(l); dft(res,l); for(int i=0;i&lt;=l;++i)&#123; res[i]=res[i]*Iex[i]%lsk; &#125; idft(res,l); fill(res+k+1,res+l,0); fill(Tmpfuc,Tmpfuc+l,0);&#125;void init()&#123; l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); pw[0]=1;inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; assert(inv[i]); &#125; Ex[0]=1; for(int i=1;i&lt;=k;++i)&#123; Ex[i]=Ex[i-1]*inv[i+1]%lsk; &#125; Inv(Ex,Iex,k+1); FFtinit(l); dft(Iex,l);&#125;int main()&#123; scanf(\"%d%*d%d\",&amp;k,&amp;n); init(); fill(Res,Res+l,0);Res[0]=1; for(int i=1;i&lt;=n;++i)&#123; lg a,b;int c; scanf(\"%lld%lld%d\",&amp;a,&amp;b,&amp;c); fill(G,G+k+1,0); fill(F,F+k+1,0); Func(b,G);Func(a-1,F); for(int j=0;j&lt;=k;++j)&#123; G[j]-=F[j]; if(G[j]&lt;0)G[j]+=lsk; &#125; fill(F,F+k+1,0); Pow(G,F,k+1,c); FFtinit(l); dft(Res,l);dft(F,l); for(int j=0;j&lt;l;++j)&#123; Res[j]=Res[j]*F[j]%lsk; &#125; idft(Res,l); fill(Res+k+1,Res+l,0); &#125; lg res=1; for(int i=2;i&lt;=k;++i)res=res*i%lsk; printf(\"%lld\",res*Res[k]%lsk); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"后缀自动机","slug":"hzzdj","date":"2018-07-15T18:26:05.000Z","updated":"2018-07-16T05:06:16.656Z","comments":true,"path":"2018/07/16/hzzdj/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/hzzdj/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738char c[MN];int n,tot=0;struct Node&#123; int maxlen,slink,tran[26];&#125;N[MN];int Nd(int _maxlen,int _tran,int _slink)&#123; N[++tot]=(Node)&#123;_maxlen,_slink,0&#125;; if(_tran)&#123; for(int i=0;i&lt;26;++i)if(N[_tran].tran[i])N[tot].tran[i]=N[_tran].tran[i];else N[tot].tran[i]=0; &#125;else for(int i=0;i&lt;26;++i)N[tot].tran[i]=0; return tot;&#125;int addchar(char cc,int u)&#123; int ch=cc-'a'; int z=Nd(N[u].maxlen+1,0,0); int v=u; while(v&amp;&amp;!N[v].tran[ch])&#123; N[v].tran[ch]=z; v=N[v].slink; &#125; if(!v)&#123;N[z].slink=1;return z;&#125; int x=N[v].tran[ch]; if(N[v].maxlen==N[x].maxlen-1)&#123; N[z].slink=x; return z; &#125; int y=Nd(N[v].maxlen+1,x,N[x].slink); N[x].slink=y;N[z].slink=y; while(v&amp;&amp;N[v].tran[ch]==x)&#123; N[v].tran[ch]=y; v=N[v].slink; &#125;return z;&#125;void insert()&#123; Nd(0,0,0); int now=1; for(int i=1;i&lt;=n;++i)&#123;now=addchar(c[i],now);&#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://tenecnt.github.io/tags/字符串/"}]},{"title":"虚树","slug":"xushu","date":"2018-07-15T18:21:10.000Z","updated":"2018-07-16T05:09:00.120Z","comments":true,"path":"2018/07/16/xushu/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/xushu/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 600005#define pil pair&lt;int,long long&gt;#define mp make_pair#define ft first#define sd second#define lg long longint n,m,K,q;int nex[MN],fr[MN],vi[MN];lg wi[MN];int tote;int tail=0,stk[MN];void add(int x,int y,lg z)&#123; nex[++tote]=fr[x];fr[x]=tote;wi[tote]=z;vi[tote]=y;&#125;int dfc=0,dfn[MN];int dep[MN],f[20][MN];lg g[20][MN];void dfs(int x,int fa)&#123; dfn[x]=++dfc;for(int i=1;i&lt;=19;++i)f[i][x]=f[i-1][f[i-1][x]],g[i][x]=min(g[i-1][x],g[i-1][f[i-1][x]]); for(int i=fr[x];i;i=nex[i])if(vi[i]!=fa)&#123; f[0][vi[i]]=x;g[0][vi[i]]=wi[i];dep[vi[i]]=dep[x]+1;dfs(vi[i],x); &#125;&#125;pil Lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); if(x==y)return mp(x,0); lg res=0x3f3f3f3f3f3f3f3f; for(int i=19;~i;--i)&#123; if(dep[f[i][x]]&gt;=dep[y])&#123; res=min(res,g[i][x]); x=f[i][x]; &#125; &#125;if(x==y) return mp(x,res); for(int i=19;~i;--i)&#123; if(f[i][x]!=f[i][y])&#123; res=min(res,min(g[i][x],g[i][y])); x=f[i][x];y=f[i][y]; &#125; &#125; return mp(f[0][x],min(res,min(g[0][x],g[0][y])));&#125;int v[MN],dd[MN];int Fr[MN],Nex[MN],Vi[MN];lg Wi[MN];int Tot=0;queue&lt;int&gt; Q;void Add(int x,int y,lg z)&#123;Nex[++Tot]=Fr[x];Wi[Tot]=z;Fr[x]=Tot;Vi[Tot]=y;Nex[++Tot]=Fr[y];Wi[Tot]=z;Fr[y]=Tot;Vi[Tot]=x;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;lg dfs2(int x,int fa)&#123; lg ans=0; // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;fa&lt;&lt;endl; for(int i=Fr[x];i;i=Nex[i])if(Vi[i]!=fa)&#123; // cout&lt;&lt;Vi[i]&lt;&lt;endl; if(dd[Vi[i]])ans+=Wi[i];else ans+=min(Wi[i],dfs2(Vi[i],x)); &#125;return ans;&#125;void bt()&#123; sort(v+1,v+m+1,cmp);Tot=0;pil L;tail=0; for(int i=0;i&lt;=m;++i)dd[v[i]]=1; // cout&lt;&lt;\"&amp;\"&lt;&lt;endl; for(int i=0;i&lt;=m;++i)&#123; // cout&lt;&lt;i&lt;&lt;endl; if(i&amp;&amp;v[i]==v[i-1])continue; // cout&lt;&lt;v[i]&lt;&lt;' '&lt;&lt;v[i-1]&lt;&lt;endl; L=Lca(stk[tail],v[i]);; while(tail&gt;1)&#123; if(dep[L.ft]&gt;dep[stk[tail]]||L.ft==stk[tail])break; // cout&lt;&lt;stk[tail]&lt;&lt;' '&lt;&lt;stk[tail-1]&lt;&lt;' '&lt;&lt;Lca(stk[tail],stk[tail-1]).sd&lt;&lt;\"&amp;&amp;&amp;\"&lt;&lt;endl; Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd); --tail; &#125; if(L.ft!=stk[tail])Fr[L.ft]=0,stk[++tail]=L.ft,Q.push(L.ft); for(int i=0;i&lt;=m;++i)dd[v[i]]=0; Fr[v[i]]=0;stk[++tail]=v[i];Q.push(v[i]); &#125; // cout&lt;&lt;\"@\"&lt;&lt;endl; while(tail!=1)Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd),--tail; printf(\"%lld\\n\",dfs2(1,1)); while(!Q.empty())&#123;int x=Q.front();Q.pop();dd[x]=0;&#125; // cout&lt;&lt;\"^\"&lt;&lt;endl;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;++i)&#123; lg z; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); &#125;dep[1]=1;dfs(1,1); scanf(\"%d\",&amp;q);v[0]=1; while(q--)&#123; // cout&lt;&lt;\"$\"&lt;&lt;endl; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;++i)scanf(\"%d\",v+i); bt(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"}]},{"title":"Helloworld","slug":"Helloworld","date":"2018-07-14T00:19:15.000Z","updated":"2018-07-22T13:04:52.981Z","comments":true,"path":"2018/07/14/Helloworld/","link":"","permalink":"http://tenecnt.github.io/2018/07/14/Helloworld/","excerpt":"","text":"第二次转移博客$ \\sqrt{\\phi} $ {1+1=2}{\\fac 1}Simple inline $ a = b + c $ \\frac{\\partial u}{\\partial t} = h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)","categories":[],"tags":[{"name":"试验","slug":"试验","permalink":"http://tenecnt.github.io/tags/试验/"},{"name":"math","slug":"math","permalink":"http://tenecnt.github.io/tags/math/"}]}]}
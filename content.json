{"meta":{"title":"tenecnt's blog","subtitle":2333,"description":null,"author":"tenecnt","url":"http://tenecnt.github.io"},"pages":[],"posts":[{"title":"my todolist","slug":"todolist","date":"2018-07-16T05:09:41.000Z","updated":"2018-07-17T06:01:28.745Z","comments":true,"path":"2018/07/16/todolist/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/todolist/","excerpt":"","text":"完成 内容 分治线段树 agc补题 done 弦图最大团 done dsu on tree","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://tenecnt.github.io/tags/规划/"}]},{"title":"多项式(1)","slug":"poly","date":"2018-07-16T04:46:48.000Z","updated":"2018-07-17T07:17:25.465Z","comments":true,"path":"2018/07/16/poly/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/poly/","excerpt":"","text":"学习了一发多项式，感觉码风得到改善 包括了： 求逆 exp 求导 积分 ln pow 水果沙拉(CodeChef) 基本思路就是将k次方多项式展开，对每一项单独计算，可以推导出是若干以e为幂的数的和的乘积，然后就是多项式了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN],Ex[MN],Iex[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN];lg F[MN],G[MN],Res[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFtinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=w*wn%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=Pow(y[0],lsk-2); return; &#125;else&#123; Inv(y,res,(d+1)&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFtinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125; y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFtinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=1; return; &#125;else&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,(d+1)&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125; ++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFtinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Func(lg u,lg *res)&#123; Tmpfuc[1]=u+1; Tmpfuc[0]=0; int l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); fill(res,res+l,0); Exp(Tmpfuc,res,k+2); for(int i=0;i&lt;=k;++i)res[i]=res[i+1]; res[k+1]=0; fill(res+k+1,res+l,0); FFtinit(l); dft(res,l); for(int i=0;i&lt;=l;++i)&#123; res[i]=res[i]*Iex[i]%lsk; &#125; idft(res,l); fill(res+k+1,res+l,0); fill(Tmpfuc,Tmpfuc+l,0);&#125;void init()&#123; l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); pw[0]=1;inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; assert(inv[i]); &#125; Ex[0]=1; for(int i=1;i&lt;=k;++i)&#123; Ex[i]=Ex[i-1]*inv[i+1]%lsk; &#125; Inv(Ex,Iex,k+1); FFtinit(l); dft(Iex,l);&#125;int main()&#123; scanf(\"%d%*d%d\",&amp;k,&amp;n); init(); fill(Res,Res+l,0);Res[0]=1; for(int i=1;i&lt;=n;++i)&#123; lg a,b;int c; scanf(\"%lld%lld%d\",&amp;a,&amp;b,&amp;c); fill(G,G+k+1,0); fill(F,F+k+1,0); Func(b,G);Func(a-1,F); for(int j=0;j&lt;=k;++j)&#123; G[j]-=F[j]; if(G[j]&lt;0)G[j]+=lsk; &#125; fill(F,F+k+1,0); Pow(G,F,k+1,c); FFtinit(l); dft(Res,l);dft(F,l); for(int j=0;j&lt;l;++j)&#123; Res[j]=Res[j]*F[j]%lsk; &#125; idft(Res,l); fill(Res+k+1,Res+l,0); &#125; lg res=1; for(int i=2;i&lt;=k;++i)res=res*i%lsk; printf(\"%lld\",res*Res[k]%lsk); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"后缀自动机","slug":"hzzdj","date":"2018-07-15T18:26:05.000Z","updated":"2018-07-16T05:06:16.656Z","comments":true,"path":"2018/07/16/hzzdj/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/hzzdj/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738char c[MN];int n,tot=0;struct Node&#123; int maxlen,slink,tran[26];&#125;N[MN];int Nd(int _maxlen,int _tran,int _slink)&#123; N[++tot]=(Node)&#123;_maxlen,_slink,0&#125;; if(_tran)&#123; for(int i=0;i&lt;26;++i)if(N[_tran].tran[i])N[tot].tran[i]=N[_tran].tran[i];else N[tot].tran[i]=0; &#125;else for(int i=0;i&lt;26;++i)N[tot].tran[i]=0; return tot;&#125;int addchar(char cc,int u)&#123; int ch=cc-'a'; int z=Nd(N[u].maxlen+1,0,0); int v=u; while(v&amp;&amp;!N[v].tran[ch])&#123; N[v].tran[ch]=z; v=N[v].slink; &#125; if(!v)&#123;N[z].slink=1;return z;&#125; int x=N[v].tran[ch]; if(N[v].maxlen==N[x].maxlen-1)&#123; N[z].slink=x; return z; &#125; int y=Nd(N[v].maxlen+1,x,N[x].slink); N[x].slink=y;N[z].slink=y; while(v&amp;&amp;N[v].tran[ch]==x)&#123; N[v].tran[ch]=y; v=N[v].slink; &#125;return z;&#125;void insert()&#123; Nd(0,0,0); int now=1; for(int i=1;i&lt;=n;++i)&#123;now=addchar(c[i],now);&#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://tenecnt.github.io/tags/字符串/"}]},{"title":"虚树","slug":"xushu","date":"2018-07-15T18:21:10.000Z","updated":"2018-07-16T05:09:00.120Z","comments":true,"path":"2018/07/16/xushu/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/xushu/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 600005#define pil pair&lt;int,long long&gt;#define mp make_pair#define ft first#define sd second#define lg long longint n,m,K,q;int nex[MN],fr[MN],vi[MN];lg wi[MN];int tote;int tail=0,stk[MN];void add(int x,int y,lg z)&#123; nex[++tote]=fr[x];fr[x]=tote;wi[tote]=z;vi[tote]=y;&#125;int dfc=0,dfn[MN];int dep[MN],f[20][MN];lg g[20][MN];void dfs(int x,int fa)&#123; dfn[x]=++dfc;for(int i=1;i&lt;=19;++i)f[i][x]=f[i-1][f[i-1][x]],g[i][x]=min(g[i-1][x],g[i-1][f[i-1][x]]); for(int i=fr[x];i;i=nex[i])if(vi[i]!=fa)&#123; f[0][vi[i]]=x;g[0][vi[i]]=wi[i];dep[vi[i]]=dep[x]+1;dfs(vi[i],x); &#125;&#125;pil Lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); if(x==y)return mp(x,0); lg res=0x3f3f3f3f3f3f3f3f; for(int i=19;~i;--i)&#123; if(dep[f[i][x]]&gt;=dep[y])&#123; res=min(res,g[i][x]); x=f[i][x]; &#125; &#125;if(x==y) return mp(x,res); for(int i=19;~i;--i)&#123; if(f[i][x]!=f[i][y])&#123; res=min(res,min(g[i][x],g[i][y])); x=f[i][x];y=f[i][y]; &#125; &#125; return mp(f[0][x],min(res,min(g[0][x],g[0][y])));&#125;int v[MN],dd[MN];int Fr[MN],Nex[MN],Vi[MN];lg Wi[MN];int Tot=0;queue&lt;int&gt; Q;void Add(int x,int y,lg z)&#123;Nex[++Tot]=Fr[x];Wi[Tot]=z;Fr[x]=Tot;Vi[Tot]=y;Nex[++Tot]=Fr[y];Wi[Tot]=z;Fr[y]=Tot;Vi[Tot]=x;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;lg dfs2(int x,int fa)&#123; lg ans=0; // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;fa&lt;&lt;endl; for(int i=Fr[x];i;i=Nex[i])if(Vi[i]!=fa)&#123; // cout&lt;&lt;Vi[i]&lt;&lt;endl; if(dd[Vi[i]])ans+=Wi[i];else ans+=min(Wi[i],dfs2(Vi[i],x)); &#125;return ans;&#125;void bt()&#123; sort(v+1,v+m+1,cmp);Tot=0;pil L;tail=0; for(int i=0;i&lt;=m;++i)dd[v[i]]=1; // cout&lt;&lt;\"&amp;\"&lt;&lt;endl; for(int i=0;i&lt;=m;++i)&#123; // cout&lt;&lt;i&lt;&lt;endl; if(i&amp;&amp;v[i]==v[i-1])continue; // cout&lt;&lt;v[i]&lt;&lt;' '&lt;&lt;v[i-1]&lt;&lt;endl; L=Lca(stk[tail],v[i]);; while(tail&gt;1)&#123; if(dep[L.ft]&gt;dep[stk[tail]]||L.ft==stk[tail])break; // cout&lt;&lt;stk[tail]&lt;&lt;' '&lt;&lt;stk[tail-1]&lt;&lt;' '&lt;&lt;Lca(stk[tail],stk[tail-1]).sd&lt;&lt;\"&amp;&amp;&amp;\"&lt;&lt;endl; Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd); --tail; &#125; if(L.ft!=stk[tail])Fr[L.ft]=0,stk[++tail]=L.ft,Q.push(L.ft); for(int i=0;i&lt;=m;++i)dd[v[i]]=0; Fr[v[i]]=0;stk[++tail]=v[i];Q.push(v[i]); &#125; // cout&lt;&lt;\"@\"&lt;&lt;endl; while(tail!=1)Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd),--tail; printf(\"%lld\\n\",dfs2(1,1)); while(!Q.empty())&#123;int x=Q.front();Q.pop();dd[x]=0;&#125; // cout&lt;&lt;\"^\"&lt;&lt;endl;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;++i)&#123; lg z; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); &#125;dep[1]=1;dfs(1,1); scanf(\"%d\",&amp;q);v[0]=1; while(q--)&#123; // cout&lt;&lt;\"$\"&lt;&lt;endl; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;++i)scanf(\"%d\",v+i); bt(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"}]},{"title":"Helloworld","slug":"Helloworld","date":"2018-07-14T00:19:15.000Z","updated":"2018-07-16T05:06:05.608Z","comments":true,"path":"2018/07/14/Helloworld/","link":"","permalink":"http://tenecnt.github.io/2018/07/14/Helloworld/","excerpt":"","text":"第二次转移博客$ \\sqrt{\\phi} $ {1+1=2}{\\fac 1}Simple inline $a = b + c$ \\frac{\\partial u}{\\partial t} = h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)","categories":[],"tags":[{"name":"试验","slug":"试验","permalink":"http://tenecnt.github.io/tags/试验/"},{"name":"math","slug":"math","permalink":"http://tenecnt.github.io/tags/math/"}]}]}
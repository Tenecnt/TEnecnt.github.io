{"meta":{"title":"tenecnt's blog","subtitle":2333,"description":null,"author":"tenecnt","url":"http://tenecnt.github.io"},"pages":[{"title":"Friends","date":"2018-10-10T10:11:31.000Z","updated":"2018-10-12T03:48:03.834Z","comments":true,"path":"friends/index.html","permalink":"http://tenecnt.github.io/friends/index.html","excerpt":"","text":"They are my friends functionendless apocrypha"}],"posts":[{"title":"【清华集训2014】玛里苟斯","slug":"MLGS","date":"2018-10-15T12:46:02.000Z","updated":"2018-10-15T13:08:53.459Z","comments":true,"path":"2018/10/15/MLGS/","link":"","permalink":"http://tenecnt.github.io/2018/10/15/MLGS/","excerpt":"","text":"线性基模板题 首先是个结论: 所有出现过的数出现的概率是相等的 很容易感性理解 然后,我们考虑k==1的情况 显然这比较简单,找到所有有1的位并起来直接求除以2就好了 然后是k==2 这里枚举任意两位合并的贡献,显然,在所有数的这两位相等并出现过一时答案和k==1一样否则就除以4就好了(容易理解) 然后是K>2 这里注意到一个性质,答案不大于2^64 所以线性基个数总共也没多少个,暴力2^n即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;#define pii pair&lt;int,int&gt;#define mp make_pair#define pb push_back#define lg long long#define db double#define lb(x) ((x)&amp;-(x))#define ft first#define sd second#define HII cerr&lt;&lt;\"HI\"&lt;&lt;endl#define LLLINE cerr&lt;&lt;\"@@@@@@@@@@@@@@@@@@@@\"&lt;&lt;endltemplate &lt;class _T_&gt;void read(_T_&amp; d)&#123; d=0;int f=1;char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar())if(c=='-')f*=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar())d=d*10+c-'0'; d*=f;&#125;/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/#define MN 200005#define ulg unsigned lgint n,k;ulg a[MN];void s1()&#123; ulg G=0; for(int i=1;i&lt;=n;++i)G|=a[i]; cout&lt;&lt;(G&gt;&gt;1); if(G&amp;1)cout&lt;&lt;\".5\";&#125;void s2()&#123; ulg res=0; for(int i=32;~i;--i)&#123; for(int j=32,fi,fj,ft;~j;--j)&#123; fi=fj=ft=0; for(int k=1;k&lt;=n;++k)&#123; fi|=a[k]&gt;&gt;i&amp;1; fj|=a[k]&gt;&gt;j&amp;1; ft|=(a[k]&gt;&gt;i&amp;1)^(a[k]&gt;&gt;j&amp;1); &#125; if(!fi||!fj)continue; res+=(1ll&lt;&lt;(i+j-ft)); &#125; &#125; cout&lt;&lt;(res&gt;&gt;1); if(res&amp;1)cout&lt;&lt;\".5\";&#125;ulg p[99],g[99];int tg=0;void Asuna()&#123; for(int i=1;i&lt;=n;++i)&#123; for(int j=63;~j;--j)&#123; if(a[i]&gt;&gt;j&amp;1)&#123; if(!p[j])&#123;p[j]=a[i];break;&#125; else a[i]^=p[j]; &#125; &#125; &#125; for(int i=0;i&lt;=63;++i)if(p[i])g[tg++]=p[i]; ulg res=0,ans=0; for(ulg i=0;i&lt;1&lt;&lt;tg;++i)&#123; ulg tot=0,G=0,B=1; for(int j=0;j&lt;tg;++j)if(i&gt;&gt;j&amp;1)tot^=g[j]; for(int j=1;j&lt;=k;++j)&#123; G*=tot;B*=tot; G+=B&gt;&gt;tg;B&amp;=(1&lt;&lt;tg)-1; &#125; res+=G;ans+=B; res+=ans&gt;&gt;tg;ans&amp;=(1&lt;&lt;tg)-1; &#125; cout&lt;&lt;res; if(ans)cout&lt;&lt;\".5\";&#125;int main()&#123; read(n);read(k); for(int i=1;i&lt;=n;++i)&#123; read(a[i]); &#125; if(k==1)s1(); else if(k==2)s2(); else Asuna(); return 0;&#125;","categories":[],"tags":[{"name":"线性基","slug":"线性基","permalink":"http://tenecnt.github.io/tags/线性基/"}]},{"title":"Berlekamp-Massey学习","slug":"BM","date":"2018-10-06T10:12:03.000Z","updated":"2018-10-06T12:11:40.711Z","comments":true,"path":"2018/10/06/BM/","link":"","permalink":"http://tenecnt.github.io/2018/10/06/BM/","excerpt":"","text":"刚刚学习了BM算法,用来求解一个数列所对应的最小次数递推式 它的复杂度是O(n^2)的 它的思路并不复杂 首先,我们有一个数列 接下来,我们要构造一个可以符合这个数列的递推式res,对于所有位置 \\sum_{1}^{q}a[i-q] \\times res[q]=0我们从左往右扫 每个位置记录delta[i]表示\\sum_{1}^{q}a[i-q] \\times res[q] 当delta[i]=0时,显然不需要任何修改 否则,我们对递推式进行一些修改使其符合数列的前i位 修改方法比较玄学……我不想讲了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;#define mp make_pair#define pb push_back#define lg long long#define pii pair&lt;lg,lg&gt;#define db double#define lb(x) ((x)&amp;-(x))#define ft first#define sd second#define HII cerr&lt;&lt;\"HI\"&lt;&lt;endl#define LLLINE cerr&lt;&lt;\"@@@@@@@@@@@@@@@@@@@@\"&lt;&lt;endltemplate &lt;class _T_&gt;void read(_T_&amp; d)&#123; d=0;int f=1;char c=getchar(); for(;c&lt;'0'||c&gt;'9';c=getchar())if(c=='-')f*=-1; for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar())d=d*10+c-'0'; d*=f;&#125;/************************************************/#define Md 998244353#define MN 5005#define poly vector&lt;int&gt;namespace&#123; inline int A(int x,int y)&#123;return x+y&gt;=Md?x+y-Md:x+y;&#125; inline int S(int x,int y)&#123;return x-y&lt;0?x-y+Md:x-y;&#125; inline int M(int x,int y)&#123;return (lg)x*y%Md;&#125; inline int P(int x,int y)&#123;int res=1;for(;y;y&gt;&gt;=1,x=M(x,x))if(y&amp;1)res=M(res,x);return res;&#125; inline int D(int x,int y)&#123;return M(x,P(y,Md-2));&#125;&#125;poly s;int n;int dta[MN];poly bm(poly s)&#123; static poly now,lst,llst; now.clear();lst.clear();llst.clear(); int fail=-1,lfail=-1,cnt=0; for(int i=0;i&lt;n;++i)&#123; int sum=S(0,s[i]); for(unsigned j=0;j&lt;now.size();++j)&#123; sum=A(sum,M(now[j],s[i-j-1])); &#125; dta[i]=sum; if(!sum)continue; fail=i; if(!cnt)&#123; lfail=fail;++cnt;now.resize(i+1);continue; &#125; int ml=D(S(0,dta[i]),dta[lfail]); ++cnt;lst.swap(now); now.clear();now.resize(i-lfail-1); now.pb(S(0,ml)); for(unsigned j=0;j&lt;llst.size();++j)&#123; now.pb(M(ml,llst[j])); &#125; if(now.size()&lt;lst.size())now.resize(lst.size()); for(unsigned j=0;j&lt;now.size();++j)&#123; now[j]=A(now[j],lst[j]); &#125; if(i-lfail+llst.size()&gt;=lst.size())llst=lst,lfail=fail; &#125; return now;&#125;int main()&#123; read(n); s.resize(n); for(int i=0;i&lt;n;++i)read(s[i]); poly res=bm(s); cerr&lt;&lt;res.size()&lt;&lt;endl; for(auto z:res)printf(\"%d \",z); return 0;&#125;","categories":[],"tags":[{"name":"数列","slug":"数列","permalink":"http://tenecnt.github.io/tags/数列/"},{"name":"递推式","slug":"递推式","permalink":"http://tenecnt.github.io/tags/递推式/"}]},{"title":"Fwt学习","slug":"fwt","date":"2018-09-19T23:26:00.000Z","updated":"2018-09-20T23:47:43.211Z","comments":true,"path":"2018/09/20/fwt/","link":"","permalink":"http://tenecnt.github.io/2018/09/20/fwt/","excerpt":"","text":"fwt主要是用来处理一类卷积问题的 首先说明一下集合幂级数 这就是一个用集合作为下标的函数 而fwt可以处理一类与集合幂级数相关的卷积问题 我们考虑\\circ是一个关于集合的运算 现在有集合A,B 我们需要求 C_{i}=\\sum_{j \\circ k =i} A_{j} \\bigotimes B_{k}其中\\bigotimes是任意运算 如何处理这个问题 我们如果能构造出一种对于A,B的变换，使得 tf(A) \\bigotimes tf(B)=tf(C)(指对应位置运算，而不是卷积) 那么就可以对A和B变换，在算出C后变换回来，得到答案 那么问题在于如何得到这种变换 我们考虑最高位的情况 我们定义tf(A_{0})为最高位为0的变换结果，tf(A_{1})为最高位为1的变换结果 现在如果可以用tf(A_{0})和tf(A_{1})表示tf(A)，那问题就能解决 接下来我们对不同的运算具体分析 这里我们先定义(A,B)指直接将A,B相接,后面会用到 xor对于xor运算，我们可以发现 tf(C)=(tf(A_{0})*tf(B_{0})+tf(A_{1})*tf(B_{1}),tf(A_{0})*tf(B_{1})+tf(A_{1})*tf(B_{0}))这里有个结论 tf(A)=(tf(A_{0})+tf(A_{1}),tf(A_{0})-tf(A_{1}))推我不会，但证明应该谁都会 同理逆变换 utf(A)=(\\frac{utf(A_{0})+utf(A_{1})}{2},\\frac{utf(A_{0})-utf(A_{1})}{2})代码 123456789101112void txor(lg *a,int n,int on=1)&#123; int U=1&lt;&lt;n; for(int i=2,p=1;i&lt;=U;i&lt;&lt;=1,p&lt;&lt;=1)&#123; for(int j=0;j&lt;U;j+=i)&#123; for(int k=j;k&lt;j+p;++k)&#123; lg A=a[k],B=a[k+p]; a[k]=(A+B)*on%Md;a[k+p]=(A-B)*on%Md; if(a[k+p]&lt;0)a[k+p]+=Md; &#125; &#125; &#125;&#125; and还是背结论吧 tf(A)=(tf(A_{0})+tf(A_{1}),tf(A_{1}))utf(A)=(utf(A_{0})-utf(A_{1}),utf(A_{1}))代码 1234567891011void tand(lg *a,int n,int on=1)&#123; int U=1&lt;&lt;n; for(int i=2,p=1;i&lt;=U;i&lt;&lt;=1,p&lt;&lt;=1)&#123; for(int j=0;j&lt;U;j+=i)&#123; for(int k=j;k&lt;j+p;++k)&#123; a[k]=(a[k]+a[k+p]*on)%Md; if(a[k]&lt;0)a[k]+=Md; &#125; &#125; &#125;&#125; ortf(A)=(tf(A_{0}),tf(A_{1})+tf(A_{0}))utf(A)=(utf(A_{0}),utf(A_{1})-utf(A_{0}))代码 1234567891011void tor(lg *a,int n,int on=1)&#123; int U=1&lt;&lt;n; for(int i=2,p=1;i&lt;=U;i&lt;&lt;=1,p&lt;&lt;=1)&#123; for(int j=0;j&lt;U;j+=i)&#123; for(int k=j;k&lt;j+p;++k)&#123; a[k+p]=(a[k+p]+a[k]*on)%Md; if(a[k+p]&lt;0)a[k+p]+=Md; &#125; &#125; &#125;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536namespace Ura&#123; void txor(lg *a,int n,int on=1)&#123; int U=1&lt;&lt;n; for(int i=2,p=1;i&lt;=U;i&lt;&lt;=1,p&lt;&lt;=1)&#123; for(int j=0;j&lt;U;j+=i)&#123; for(int k=j;k&lt;j+p;++k)&#123; lg A=a[k],B=a[k+p]; a[k]=(A+B)*on%Md;a[k+p]=(A-B)*on%Md; if(a[k+p]&lt;0)a[k+p]+=Md; &#125; &#125; &#125; &#125; void tand(lg *a,int n,int on=1)&#123; int U=1&lt;&lt;n; for(int i=2,p=1;i&lt;=U;i&lt;&lt;=1,p&lt;&lt;=1)&#123; for(int j=0;j&lt;U;j+=i)&#123; for(int k=j;k&lt;j+p;++k)&#123; a[k]=(a[k]+a[k+p]*on)%Md; if(a[k]&lt;0)a[k]+=Md; &#125; &#125; &#125; &#125; void tor(lg *a,int n,int on=1)&#123; int U=1&lt;&lt;n; for(int i=2,p=1;i&lt;=U;i&lt;&lt;=1,p&lt;&lt;=1)&#123; for(int j=0;j&lt;U;j+=i)&#123; for(int k=j;k&lt;j+p;++k)&#123; a[k+p]=(a[k+p]+a[k]*on)%Md; if(a[k+p]&lt;0)a[k+p]+=Md; &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"fwt","slug":"fwt","permalink":"http://tenecnt.github.io/tags/fwt/"}]},{"title":"Lct学习","slug":"lct","date":"2018-09-01T10:06:29.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/09/01/lct/","link":"","permalink":"http://tenecnt.github.io/2018/09/01/lct/","excerpt":"","text":"终于还是学习了一下lct(然而我还是不会证复杂度) 讲道理，这东西比想象的要来的简单 概述首先，这个东西是用来维护树的信息的 可以支持link和cut操作(所以叫做link-cut-tree) 这个link和cut，顾名思义，就是把图断开和接上 如何做到呢？ 同是用数据结构维护一树，我们会想到树剖 树剖分重链轻链，这里也可以这样 但略有偏差，这里重链不一定要最大，而且一个点向下可以没有重链 但重链与轻链随时会改变，那怎么办呢 我们不用线段树维护，我们用splay 支持分裂合并的平衡树都可以完成这件事 但为什么选splay？因为出于某种玄学的复杂度证明用splay是一个log的…… 现在，我们用一棵splay表示一条重链，中序遍历表示它从上往下的顺序 那么每次如何操作呢？ 我们需要制造出这么几个操作： is_root它的意思就是判断一个点是否是一棵splay的根 注意这是splay的根，而不是树的根我被坑了一次 注意这个函数没有在其他splay出现过，这里只是为了不用写分裂合并 方法很简单，用“父亲有没有孩子是自己”来标记是否为根 这使lct中的splay短了很多 123bool Isroot(int x)&#123; return N[N[x].fa][0]!=x&amp;&amp;N[N[x].fa][1]!=x;&#125; access它指打通一个点到根的链(打成重链)就是不停spaly，然后把父亲的儿子变成自己，很好理解12345void Access(int x)&#123; for(int i=0;x;i=x,x=N[x].fa)&#123; Splay(x);N[x][1]=i;Up(x);//Up-&gt;上传标记 &#125;&#125; mkroot把一个点变成根(树的根)有了access，然后splay它他就成了splay的根了，但实际中序遍历还是最后那再reverse一下就好了啊123void Mkroot(int x)&#123; Access(x);Splay(x);N[x].fl^=1;&#125; 还有一些零碎操作比如findroot什么的，很好想清楚，就不讲了 题弹飞绵羊明显每次把儿子a从b接到c上，没有什么困难的东西123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std; #define MN 400005 int v[MN];int n; namespace CFA&#123;//China Football Association!! struct Node&#123; int fa,s[2],fl,sz; int&amp; operator[](int x)&#123;return s[x];&#125; &#125;N[MN]; bool Isroot(int x)&#123; return N[N[x].fa][0]!=x&amp;&amp;N[N[x].fa][1]!=x; &#125; void Up(int x)&#123; N[x].sz=N[N[x][0]].sz+N[N[x][1]].sz+1; &#125; void Down(int x)&#123; if(!N[x].fl)return; swap(N[x][1],N[x][0]); N[N[x][0]].fl^=1; N[N[x][1]].fl^=1; N[x].fl=0; &#125; void Rotate(int x,int y=0)&#123; int p=N[x].fa,f=N[p][0]==x,pp=N[p].fa; N[p][f^1]=N[x][f]; N[N[x][f]].fa=p; N[x][f]=p;N[p].fa=x; Up(p);Up(x); if(N[pp][0]==p)N[pp][0]=x; if(N[pp][1]==p)N[pp][1]=x; N[x].fa=pp; if(y)Rotate(y); &#125; int stk[MN],ssz=0; void Splay(int x)&#123; assert(ssz==0); stk[++ssz]=x; for(int i=x;!Isroot(i);i=N[i].fa)stk[++ssz]=N[i].fa; while(ssz)Down(stk[ssz--]); while(!Isroot(x))&#123; int p=N[x].fa,f=N[p][1]==x,pp=N[p].fa,ff=N[pp][1]==p; if(Isroot(p))Rotate(x); else if(f==ff)Rotate(p,x); else Rotate(x,x); &#125; &#125; void Access(int x)&#123; for(int i=0;x;i=x,x=N[x].fa)&#123; Splay(x);N[x][1]=i;Up(x); &#125; &#125; void Mkroot(int x)&#123; Access(x);Splay(x);N[x].fl^=1; &#125; void Link(int x,int y)&#123; Mkroot(x);N[x].fa=y; &#125; void Cut(int x,int y)&#123; Mkroot(x);Access(y);Splay(y); N[y][0]=N[x].fa=0; &#125;&#125; int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n+1;++i)CFA::N[i].sz=1; for(int i=1;i&lt;=n;++i)&#123; scanf(\"%d\",v+i); CFA::Link(i,min(n+1,i+v[i])); &#125; int q; scanf(\"%d\",&amp;q); while(q--)&#123; int op,x,y; scanf(\"%d\",&amp;op); if(op==1)&#123; scanf(\"%d\",&amp;x);++x; CFA::Mkroot(n+1);CFA::Access(x);CFA::Splay(x); printf(\"%d\\n\",CFA::N[x].sz-1); &#125;else&#123; scanf(\"%d%d\",&amp;x,&amp;y);++x; CFA::Cut(x,min(n+1,x+v[x])); CFA::Link(x,min(n+1,x+(v[x]=y))); &#125; &#125; return 0;&#125; 洞穴勘测明显每次判断联不联通，没有什么困难的东西1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 10005namespace Tohsaka&#123; struct Node&#123; int fa,fl,s[2]; int&amp; operator[](int x)&#123;return s[x];&#125; &#125;N[MN]; inline void Down(int x)&#123; if(N[x].fl)&#123; N[N[x][0]].fl^=1;N[N[x][1]].fl^=1; swap(N[x][0],N[x][1]); N[x].fl=0; &#125; &#125; inline bool Isroot(int x)&#123; return N[N[x].fa][0]!=x&amp;&amp;N[N[x].fa][1]!=x; &#125; inline void Rotate(int x)&#123; int p=N[x].fa,pp=N[p].fa; int d=N[p][0]==x; N[N[x][d]].fa=p; N[p][d^1]=N[x][d]; N[p].fa=x;N[x][d]=p; if(N[pp][0]==p)N[pp][0]=x; if(N[pp][1]==p)N[pp][1]=x; N[x].fa=pp; &#125; int stk[MN],ttk=0; void Splay(int x)&#123; stk[++ttk]=x; for(int i=x;!Isroot(i);i=N[i].fa)stk[++ttk]=N[i].fa; while(ttk)Down(stk[ttk--]); while(!Isroot(x))&#123; int p=N[x].fa,pp=N[p].fa; if(Isroot(p))&#123;Rotate(x);continue;&#125; int f=N[p][1]==x,ff=N[pp][1]==p; if(f==ff)&#123; Rotate(p),Rotate(x); &#125;else&#123; Rotate(x),Rotate(x); &#125; &#125; &#125; inline void Access(int x)&#123; for(int i=0;x;i=x,x=N[x].fa)&#123; Splay(x);N[x][1]=i; &#125; &#125; inline void Mkroot(int x)&#123; Access(x);Splay(x);N[x].fl^=1; &#125; inline void Link(int x,int y)&#123; Mkroot(x);N[x].fa=y; &#125; inline void Cut(int x,int y)&#123; Mkroot(x);Access(y);Splay(y); N[x].fa=N[y][0]=0; &#125; inline int Fdroot(int x)&#123; Access(x);Splay(x); while(N[x][0])x=N[x][0]; Splay(x); return x; &#125;&#125;int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1,x,y;i&lt;=m;++i)&#123; char cc[11]; scanf(\"%s%d%d\",cc,&amp;x,&amp;y); if(cc[0]=='Q')&#123; Tohsaka::Mkroot(x); if(Tohsaka::Fdroot(y)!=x)puts(\"No\"); else puts(\"Yes\"); &#125; if(cc[0]=='C')&#123; Tohsaka::Link(x,y); &#125; if(cc[0]=='D')&#123; Tohsaka::Cut(x,y); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"},{"name":"数据结构","slug":"数据结构","permalink":"http://tenecnt.github.io/tags/数据结构/"},{"name":"lct","slug":"lct","permalink":"http://tenecnt.github.io/tags/lct/"}]},{"title":"(CC 2018AugestLong)Interactive Matrix","slug":"CCAugINM","date":"2018-08-09T02:51:29.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/08/09/CCAugINM/","link":"","permalink":"http://tenecnt.github.io/2018/08/09/CCAugINM/","excerpt":"","text":"这真是一道神奇的乱搞题 首先限制说明，询问次数可以达到4n我们发现，每次询问四个顶点，当一边的两个值都大于V时，可以除去这一边如果这样走完整个矩阵，答案刚好4n但是这里就出现了所不能解决的情况 大 小 小 大 这样什么都删不掉 这可如何是好？ 注意到上下左右关于V的大小关系 其一定是 大 大 小 小 大 大 大 小 小 小 大 大 或 大 大 小 小 大 大 小 小 小 小 小 大 这类的情况 也就是说，“大”与“小”分别占据角上一部分，并且扩展方向是单调的 这时爆扫边界，复杂度就是两条边界的长度，但确定边界开始位置时，要爆扫一边，所以最坏情况下要6n 我码完后才发现这有点假了其实本来发现不了的，但交题时网炸了，菊花转不出，这时复杂度一分析好像不对，但顺手还是交了一发（毕竟写完了嘛），然后。。。 过了！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 1005int V;int a[MN][MN];int b[MN],c[MN];int k=0,K;int Qry(int x,int y)&#123; if(a[x][y])return a[x][y]; ++k; printf(\"1 %d %d\\n\",x,y); fflush(stdout); int res; scanf(\"%d\",&amp;res); if(res==V)&#123; printf(\"2 %d %d\\n\",x,y); fflush(stdout); exit(0); &#125; if(k==K)&#123; puts(\"2 -1 -1\"); fflush(stdout); exit(0); &#125; return a[x][y]=res;&#125;void Rin(int u,int d,int l,int r)&#123; int Vul=Qry(u,l); int Vdl=Qry(d,l); int Vur=Qry(u,r); int Vdr=Qry(d,r); if(Vul&gt;V)&#123; int x=u,y=l; while(x&gt;=u&amp;&amp;x&lt;=d&amp;&amp;y&gt;=l&amp;&amp;y&lt;=r)&#123; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&gt;V)++y;if(y&gt;r)--y; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&lt;V)--y; ++x; &#125; x=d,y=r; while(x&gt;=u&amp;&amp;x&lt;=d&amp;&amp;y&gt;=l&amp;&amp;y&lt;=r)&#123; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&gt;V)--y;if(y&lt;l)++y; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&lt;V)++y; --x; &#125; &#125;else&#123; int x=d,y=l; while(x&gt;=u&amp;&amp;x&lt;=d&amp;&amp;y&gt;=l&amp;&amp;y&lt;=r)&#123; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&gt;V)++y;if(y&gt;r)--y; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&lt;V)--y; --x; &#125; x=u,y=r; while(x&gt;=u&amp;&amp;x&lt;=d&amp;&amp;y&gt;=l&amp;&amp;y&lt;=r)&#123; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&gt;V)--y;if(y&lt;l)++y; while(y&gt;=l&amp;&amp;y&lt;=r&amp;&amp;Qry(x,y)&lt;V)++y; ++x; &#125; &#125;&#125;int main()&#123; int n; scanf(\"%d%d%d\",&amp;n,&amp;K,&amp;V); int u=1,l=1,r=n,d=n; while(u&lt;=d&amp;&amp;r&gt;=l)&#123; //cout&lt;&lt;\"ID\"&lt;&lt;' '&lt;&lt;u&lt;&lt;' '&lt;&lt;d&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl; if(Qry(u,l)&gt;V&amp;&amp;Qry(u,r)&gt;V||Qry(u,l)&lt;V&amp;&amp;Qry(u,r)&lt;V)&#123;++u;continue;&#125; if(Qry(d,l)&gt;V&amp;&amp;Qry(d,r)&gt;V||Qry(d,l)&lt;V&amp;&amp;Qry(d,r)&lt;V)&#123;--d;continue;&#125; if(Qry(u,l)&gt;V&amp;&amp;Qry(d,l)&gt;V||Qry(u,l)&lt;V&amp;&amp;Qry(d,l)&lt;V)&#123;++l;continue;&#125; if(Qry(u,r)&gt;V&amp;&amp;Qry(d,r)&gt;V||Qry(u,r)&lt;V&amp;&amp;Qry(d,r)&lt;V)&#123;--r;continue;&#125; break; &#125; //cout&lt;&lt;\"#####\"&lt;&lt;endl; if(u&gt;d||r&lt;l)&#123; puts(\"2 -1 -1\"); fflush(stdout); return 0; &#125; Rin(u,d,l,r); puts(\"2 -1 -1\"); fflush(stdout); return 0;&#125;","categories":[],"tags":[{"name":"交互题","slug":"交互题","permalink":"http://tenecnt.github.io/tags/交互题/"},{"name":"乱搞","slug":"乱搞","permalink":"http://tenecnt.github.io/tags/乱搞/"}]},{"title":"Min_25筛","slug":"min25s","date":"2018-07-27T12:35:50.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/27/min25s/","link":"","permalink":"http://tenecnt.github.io/2018/07/27/min25s/","excerpt":"","text":"这个东西续了我好长时间，并且让我意识到状态真的不太对 Min_25筛这个东西，感觉对于不同题，思路上还是有些不同的，只是大致方向一致，所以也没有很多具体模板这种东西吧 大致思路是这样的：首先，处理的内容大致就是积性函数或者什么类似积性函数的奇怪东西前缀和，复杂度大概是什么O(n^{0.69})(这个的证明真的不会) 我们假设如此一个问题： f(n) = \\begin{cases} 1& if\\;n = 1\\\\ g(p,e)& if\\;n = y^e,\\;e > 0,\\;p\\;is\\;a\\;prime \\\\ f(x)*f(y) & if\\;x*y=n,\\;x\\perp y \\\\ \\end{cases}然后求S(N)=\\displaystyle\\sum_{1 \\leqslant j \\leqslant N} f(j) 考虑到一个数除以其最大质因数后一定不剩大于\\sqrt{N}的质因数，这是我们解决这个问题的关键。 考虑枚举因数M: \\begin{aligned} & M' = M/P^{e}\\;,e>0\\\\ & P\\;is\\;the\\;max\\;prime\\;factor\\;of\\;M \\end{aligned}根据这是个积性函数，可知： \\begin{aligned}& f(N)=\\sum_{M'} f(M')*(1+\\sum_{F < p \\leqslant N/M'} f(p))\\\\& F\\;is\\;the\\;largrst\\;prime\\;factor\\;of\\;M'\\;and\\;p\\;is\\;a\\;prime \\end{aligned}(这只是个大致的式子，不完全对，细节可能有问题，可能需要调整) 那么f(M')可以递归解决，问题在于求\\sum_{F < p \\leqslant N/M'} f(p)(自此以下p都为质数) 首先，设h(x)=\\sum_{p \\leqslant x} f(p)，将其转化为h(N/M')-h(F-1) 那么解决了h(x)的求解就能解决问题了 对此如何处理呢？ 首先，如果p不止是质数的话(将合数看做质数处理)，大部分的前缀和都能O(1)求出 例如\\sigma(n^k)(n的k次的因子数) 然后考虑筛的实现 我们回想有什么筛是大家熟知的 埃拉托色尼筛？ 考虑像埃拉托色尼筛一样搞 埃拉托色尼筛怎么搞的？ 每个数p用来筛大于p^2的所有数 所以这里也是这样：从小到大枚举每个质数，用其对大于其平方的数的前缀和进行处理 (这里注意，要处理h(x)的数仅有O(\\sqrt{N})个，为1,2,3,...,N/3,N/2,N/1) 这样就能完美筛出h(x)了 有这么几道具体题目： spoj-DIVCNTK这题就是求f(n)=\\displaystyle\\sum_{1 \\leqslant i \\leqslant n}\\sigma(i^k) 这里首先去掉1这个因数，就成了积性函数。 而f(p)=k的前缀和可以轻松求出。 直接上就好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 4000005#define lg unsigned long longint pri[MN],totp=0,S;bool vd[MN];lg ns[MN],tns=0,h[MN];lg n,k;int D(lg X)&#123; return X&lt;=S?X:tns-n/X+1;&#125;lg f(lg n,int g)&#123;//递归求解f,f(n,g)☞n以内不包括大于pri[g]的质因数的数 if(n&lt;1||pri[g+1]&gt;n)return 0; lg res=h[D(n)]-g*(k+1); while(1ll*pri[g+1]*pri[g+1]&lt;=n)&#123; int p=pri[g+1]; lg t=n/p,e=k+1; while(t&gt;=p)res+=f(t,g+1)*e+e+k,e+=k,t/=p; ++g; &#125;return res;&#125;lg slv(lg n)&#123; S=sqrt(n);//处理h(x) tns=0; for(int i=1;i&lt;=S;++i)&#123; ns[++tns]=i; &#125; for(int i=S;i;--i)&#123; if(n/i&gt;S)ns[++tns]=n/i; &#125; for(int i=1;i&lt;=tns;++i)&#123; h[i]=(ns[i]-1)*(k+1); &#125; int H=1;lg up=0; for(int P=1;pri[P]&lt;=S;++P)&#123; int p=pri[P]; while(ns[H]&lt;1ll*p*p)++H; for(int i=tns;i&gt;=H;--i)&#123; h[i]-=h[D(ns[i]/p)]-up; &#125;up+=k+1; &#125; return f(n,0)+1;&#125;void init()&#123; for(int i=2;i&lt;MN;++i)&#123; if(vd[i])continue; pri[++totp]=i; for(int j=i+i;j&lt;MN;j+=i)vd[j]=1; &#125;&#125;int main()&#123; init();int Cas; for(scanf(\"%d\",&amp;Cas);Cas;--Cas)&#123; scanf(\"%llu%llu\",&amp;n,&amp;k); printf(\"%llu\\n\",slv(n)); &#125; return 0;&#125; APS2这题求的是最小质因数前缀和 考虑枚举最小质因数，要乘的就是最小质因数大于等于与n的数的个数 这个就可以用Min_25筛搞了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 4000005#define ulg unsigned long longint pri[MN],totp=0,S;ulg tp[MN];bool vd[MN];ulg ns[MN],tns=0,h[MN],d[MN];ulg n;int D(ulg X)&#123; return X&lt;=S?X:tns-n/X+1;&#125;ulg c(ulg n,int g)&#123; if(n&lt;1||pri[g]&gt;n)&#123; return 0; &#125; ulg res=d[D(n)]-d[D(pri[g]-1)]; while(1ll*pri[g]*pri[g]&lt;=n)&#123; ulg t=n/pri[g]; while(t&gt;=pri[g])&#123; res+=c(t,g+1); ++res; t/=pri[g]; &#125;++g; &#125; return res;&#125;ulg f(ulg n,int g)&#123; if(n&lt;1||pri[g]&gt;n)return 0; ulg res=h[D(n)]; while(1ll*pri[g]*pri[g]&lt;=n)&#123; ulg t=n/pri[g]; res+=c(t,g)*pri[g]; ++g; &#125;return res;&#125;ulg slv(ulg n)&#123; S=sqrt(n);tns=0; for(int i=1;i&lt;=S;++i)&#123; ns[++tns]=i; &#125; for(int i=S;i;--i)&#123; if(n/i&gt;S)ns[++tns]=n/i; &#125; for(int i=1;i&lt;=tns;++i)&#123; if(!(ns[i]&amp;1))h[i]=(ns[i]+2)/2*(ns[i]-1); else h[i]=(ns[i]-1)/2*(ns[i]+2); d[i]=ns[i]-1; &#125; int H=1; for(int p=2;p&lt;=S;++p)if(!vd[p])&#123; while(ns[H]&lt;1ll*p*p)++H; for(int i=tns;i&gt;=H;--i)&#123; h[i]-=(h[D(ns[i]/p)]-h[p-1])*p; d[i]-=(d[D(ns[i]/p)]-d[p-1]); &#125; &#125; return f(n,1);&#125;void init()&#123; for(int i=2;i&lt;MN;++i)&#123; if(vd[i])continue; pri[++totp]=i; for(int j=i+i;j&lt;MN;j+=i)vd[j]=1; &#125; for(int i=2;i&lt;MN;++i)tp[i]=pri[i]+tp[i-1];&#125;int main()&#123; init();int Cas; for(scanf(\"%d\",&amp;Cas);Cas;--Cas)&#123; scanf(\"%lld\",&amp;n); printf(\"%llu\\n\",slv(n)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://tenecnt.github.io/tags/数论/"},{"name":"数论筛","slug":"数论筛","permalink":"http://tenecnt.github.io/tags/数论筛/"}]},{"title":"Stirling学习","slug":"Stirling","date":"2018-07-24T13:28:44.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/24/Stirling/","link":"","permalink":"http://tenecnt.github.io/2018/07/24/Stirling/","excerpt":"","text":"昨天学习了一发Stirling数哒哒哒，感觉很有用 首先，Stirling数哒哒哒分两类 第一类Stirling数\\begin{bmatrix} n \\\\ k \\end{bmatrix}这表示第一类Stirling数哒哒哒 意义由 n 个数构成置换的方案数 递推式\\begin{bmatrix} n \\\\ k \\end{bmatrix} = \\begin{bmatrix} n-1 \\\\ k-1 \\end{bmatrix} + (n-1)\\begin{bmatrix} n-1 \\\\ k \\end{bmatrix}解释很简单，对于新加的n,要么单独成一个置换，要么放在某个的后面 用途x^{\\overline{n}} = \\sum_{k}\\begin{bmatrix} n \\\\ k \\end{bmatrix}x^{k}x^{\\underline{n}} = \\sum_{k}\\begin{bmatrix} n \\\\ k \\end{bmatrix}(-1)^{n-k}x^{k}第二类Stirling数\\begin{Bmatrix} n \\\\ k \\end{Bmatrix}这表示第二类Stirling数哒哒哒 意义由 n 个数构成集合的方案数 递推式\\begin{Bmatrix} n \\\\ k \\end{Bmatrix} = \\begin{Bmatrix} n-1 \\\\ k-1 \\end{Bmatrix} + k\\begin{Bmatrix} n-1 \\\\ k \\end{Bmatrix}解释很简单，对于新加的n,要么单独成一个置换，要么放在某个的后面 用途x^{n} = \\sum_{k}\\begin{Bmatrix} n \\\\ k \\end{Bmatrix}x^{\\underline{k}}x^{n} = \\sum_{k}\\begin{Bmatrix} n \\\\ k \\end{Bmatrix}(-1)^{n-k}x^{\\overline{k}}","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://tenecnt.github.io/tags/组合数学/"}]},{"title":"(CC JulyLong)Tom and Jerry","slug":"CCJulyTom","date":"2018-07-24T11:54:37.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/24/CCJulyTom/","link":"","permalink":"http://tenecnt.github.io/2018/07/24/CCJulyTom/","excerpt":"","text":"这道题首先先猜一个结论：这是要求最大团 但是最大团怎么跑200000呢 这里有一个优越的性质：这是一个弦图 弦图有一个优秀的性质：它有一个完美消除序列 完美消除序列是一个序列，其中每一项在所有往后的项构成的图中都是关键点 还有一个性质：它的最大团大小就是他的最大染色数 还有一个性质：按逆完美消除序列操作贪心染色就是最优解 所以求出完美消除序列就行了 于是要用一个神奇的算法，它叫MCS 它倒过来求完美消除序列 每次取与现在已被取的点中度数最大的 弄一堆链表(vector)就能操作了 以上所有内容，全部只会用不会证。证明？不存在的～～留下一个好东西1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 400005int fr[MN],nex[MN&lt;&lt;1],vi[MN&lt;&lt;1],tot=0;void add(int x,int y)&#123; nex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;&#125;int n,m;int vd[MN],d[MN];struct Node&#123; int v,id;&#125;;bool operator&lt;(Node A,Node B)&#123; return A.v&lt;B.v||A.v==B.v&amp;&amp;A.id&lt;B.id;&#125;vector&lt;int&gt; V[MN];void clear()&#123; memset(fr,0,sizeof fr); tot=0; memset(vd,0,sizeof vd); memset(d,0,sizeof d); for(int i=0;i&lt;=n;++i)V[i].clear();&#125;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--)&#123; clear(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1,a,b;i&lt;=m;++i)&#123; scanf(\"%d%d\",&amp;a,&amp;b); add(a,b);add(b,a); &#125; for(int i=1;i&lt;=n;++i)&#123; V[0].push_back(i); &#125;int Ms=0;int res=0; for(int i=1;i&lt;=n;++i)&#123; while(V[Ms].size()==0||vd[V[Ms][V[Ms].size()-1]])&#123; if(V[Ms].size()==0)--Ms; else V[Ms].pop_back(); &#125; int x=V[Ms][V[Ms].size()-1],sz=1; V[Ms].pop_back(); vd[x]=1; //cout&lt;&lt;x&lt;&lt;\"#\"&lt;&lt;endl; for(int i=fr[x];i;i=nex[i])if(!vd[vi[i]])&#123; ++d[vi[i]]; V[d[vi[i]]].push_back(vi[i]); Ms=max(Ms,d[vi[i]]); //Q.push((Node)&#123;d[vi[i]],vi[i]&#125;); &#125;else ++sz; res=max(res,sz); //cout&lt;&lt;sz&lt;&lt;endl; &#125; printf(\"%d\\n\",res); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"},{"name":"最大团","slug":"最大团","permalink":"http://tenecnt.github.io/tags/最大团/"}]},{"title":"bzoj5170(Fable)","slug":"bzoj5170","date":"2018-07-24T10:57:35.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/24/bzoj5170/","link":"","permalink":"http://tenecnt.github.io/2018/07/24/bzoj5170/","excerpt":"","text":"QwQ有点有趣 明显，平衡树可以秒这道题 但是总是感觉太烦了。 有没有好一点的方法呢？ 如果我们考虑每一个数，如果没有向后送，向前移的位置数等于前面比它大的数，显然这可以用树状数组搞。 而剩下的数相对顺序一定排好了 所以把剩下的数sort一下填进去就好了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 200005#define lb(x) ((x)&amp;(-x))#define ft first#define sd second#define pii pair&lt;int,int&gt;int c[MN],res[MN],b[MN],n,k;pii a[MN];int add(int x,int y)&#123; for(;x&lt;=n;x+=lb(x))c[x]+=y;&#125;bool C(pii A,pii B)&#123; return A.sd&lt;B.sd;&#125;int qry(int x)&#123; int res=0; for(;x;x-=lb(x))res+=c[x]; return res;&#125;priority_queue&lt;int&gt; pQ;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1;i&lt;=n;++i)&#123; scanf(\"%d\",&amp;a[i].ft); a[i].sd=i; &#125; sort(a+1,a+n+1); for(int i=n;i;--i)&#123; b[a[i].sd]=qry(a[i].sd); add(a[i].sd,1); if(b[a[i].sd]&gt;k)res[a[i].sd-k]=a[i].ft; else pQ.push(a[i].ft); &#125; for(int i=n;i;--i)&#123; if(!res[i])res[i]=pQ.top(),pQ.pop(); &#125; for(int i=1;i&lt;=n;++i)printf(\"%d\\n\",res[i]); return 0;&#125;","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://tenecnt.github.io/tags/树状数组/"}]},{"title":"NOI2018屠龙勇士(dragon)","slug":"noi18d","date":"2018-07-22T11:51:21.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/22/noi18d/","link":"","permalink":"http://tenecnt.github.io/2018/07/22/noi18d/","excerpt":"","text":"好吧这道题其实是道CRT裸题…… 首先哪条龙选哪把剑是固定的。拿个set(multiset)/map扫一遍即可。当然也可以自己写平衡树啊2333 然后就是若干 k_{i}x \\equiv a_i (mod\\;p_i) 可以讲整个柿子中的k_i,a_i,p_i同除gcd(k_i,p_i)(如果a_i无法整除就无解了)，这肯定对答案是无影响的。然后，江柿子两边同除k_i(已经有逆元了)，变为n个形为x \\equiv a_i/k_i(mod\\;p_i)的柿子这就成了裸的CRT了。对于一个CRT， \\begin{equation} \\begin{cases} x \\equiv a_1(mod\\;p_1) \\\\ x \\equiv a_2(mod\\;p_2) \\\\ gcd(p_1,p_2) = d \\end{cases} \\end{equation}可得 x \\equiv p_1*(a_2-a_1)*(p_1/d)^{-1}/d+a_1(mod\\;n_1n_2/d)于是扫一遍就能A了。注意爆long long，要写慢速乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 200005#define ft first#define sd secondlg a[MN],p[MN],k[MN],ne[MN];int n,m;lg Ep1,Ep2,G,Q;map&lt;lg,int&gt; M;map&lt;lg,int&gt;::iterator it;lg gcd(lg A,lg B)&#123; return B==0?A:gcd(B,A%B);&#125;void exgcd(lg x,lg y,lg&amp; a,lg&amp; b)&#123; if(y==0)a=1,b=0; else exgcd(y,x%y,b,a),b-=x/y*a;&#125;lg inv(lg x,lg y)&#123; lg A,B; exgcd(x,y,A,B); return (A%y+y)%y;&#125;lg Qx(lg x,lg y,lg md)&#123; lg res=0,f=1; if(x&lt;0)x=-x,f=-f; if(y&lt;0)y=-y,f=-f; for(;y;y&gt;&gt;=1,x=(x+x)%md)if(y&amp;1)res=(res+x)%md; res*=f;res%=md;res+=md;res%=md; return res;&#125;lg work()&#123; lg F=1; for(int i=1;i&lt;=n;++i)&#123; int H=gcd(k[i],p[i]); if(a[i]%H)return -1; k[i]/=H,p[i]/=H,a[i]/=H; &#125; //for(int i=1;i&lt;=n;++i)cout&lt;&lt;k[i]&lt;&lt;endl; for(int i=1;i&lt;=n;++i)&#123; F=max(F,(a[i]-1)/k[i]+1); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]-=F*k[i]; a[i]%=p[i]; a[i]+=p[i]; a[i]%=p[i]; &#125; if(G==1)&#123; return F; &#125; for(int i=1;i&lt;=n;++i)&#123; lg H=gcd(k[i],p[i]); a[i]=Qx(a[i],inv(k[i],p[i]),p[i]); &#125; lg np=p[1],na=a[1]; for(int i=2;i&lt;=n;++i)&#123; lg E=gcd(np,p[i]),HH=p[i]/E,QQ=HH*np; //assert(QQ&gt;=0); if((a[i]-na)%E)return -2; exgcd(np,p[i],Ep1,Ep2); Ep1=Qx(Ep1,(a[i]-na)/E,HH); na+=Qx(np,Ep1,QQ); na%=QQ; np=QQ; &#125; return F+na;&#125;int main()&#123; freopen(\"dragon.in\",\"r\",stdin); freopen(\"dragon.out\",\"w\",stdout); int T; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d%d\",&amp;n,&amp;m);M.clear();G=1; for(int i=1;i&lt;=n;++i)scanf(\"%lld\",a+i); for(int i=1;i&lt;=n;++i)&#123; scanf(\"%lld\",p+i); G*=(p[i]==1); &#125; for(int i=1;i&lt;=n;++i)scanf(\"%lld\",ne+i); for(int i=1,b;i&lt;=m;++i)&#123; scanf(\"%d\",&amp;b); ++M[b]; &#125; for(int i=1;i&lt;=n;++i)&#123; if((M.begin()-&gt;ft)&gt;a[i])&#123; k[i]=M.begin()-&gt;ft; --M[M.begin()-&gt;ft]; if((M.begin()-&gt;sd)==0)M.erase(M.begin()); &#125;else&#123; ++M[a[i]]; it=M.find(a[i]); if((it-&gt;sd)&gt;1)&#123; M[a[i]]-=2; k[i]=a[i]; it=M.find(a[i]); if(it-&gt;sd==0)M.erase(it); ++M[ne[i]]; continue; &#125; if((it-&gt;sd)==1)--it; --M[a[i]]; k[i]=it-&gt;ft; --M[it-&gt;ft]; if((it-&gt;sd)==0)M.erase(it); it=M.find(a[i]); if(it-&gt;sd==0)M.erase(it); &#125; ++M[ne[i]]; &#125; printf(\"%lld\\n\",work()); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://tenecnt.github.io/tags/数论/"},{"name":"CRT","slug":"CRT","permalink":"http://tenecnt.github.io/tags/CRT/"}]},{"title":"NOI2018冒泡排序(inverse)","slug":"noi18b","date":"2018-07-19T12:22:44.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/19/noi18b/","link":"","permalink":"http://tenecnt.github.io/2018/07/19/noi18b/","excerpt":"","text":"这道题的冒泡排序好像是假的 首先，根据那个啥的定义，首先必须得到坏序列的充要条件是 \\exists\\;{i a_{k}证明就感性理解一下，对于中间那个数，无论它目标位置是在左边还是右边，都有至少一步向反方向移动，所以一定是坏序列了 80 然后80分就很简单了，设计这么一个函数，F_{i,j}表示目前有i个数需要排列，但是由于前面的数的限制，最小的$j$个数的相对顺序必须递增。 容易得到递推式： F_{i,j} = \\sum^{j-1}_{k=i} F_{i-1,k}其实就是枚举拿的是哪个数，最小数就是F_{i-1,k},否则对应了各个数。 然后就拿这个东西像数位dp一样扫一遍过去就是O(n^2)了 100 满分算法就比较神仙了 曾经有这样一道题 为了解决在一条直线限制下A点走到B点的方案数，这里用到了一种高妙的方法，将起点按对称线翻转计数，这里的每一种方案刚好一一对应了一种原起点到终点的一种路线(想象将该路线第一次遇到对称轴前的路径翻折)，于是这样，就能解决上述的小问题。 那么，对于这个问题，我们可以发现，在dp转移的时候，其实对应了一个长度为2n的括号序列。 每次转移对应了在原串后面加上了若干左括号和一个右括号（当取的是最小数时对应0个左括号+1个右括号） 然后将左括号和右括号转化成在二维坐标上的两个向右上（下）45度的向量，所以这就成了一个在二维上自由行走（但不能低于x轴）的问题，同时必须满足中途没有低于过一条线（除非已经高于过这条直线）。 于是想80分一样，对于每一位统计在这位超过限制的答案数，这里可以发现，只要先多出现了一个左括号，后面的左括号都能在自由行走中补充，所以每位的统计可以O(1)，这就使总体复杂度化为O(n)了 可是我为了偷懒，没有维护目前比最大值小的值数，用树状数组，多了一个log 能过就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define lg long long#define MN 1200005#define lsk 998244353#define lb(x) ((x)&amp;(-(x)))int n;int a[MN&gt;&gt;1],c[MN&gt;&gt;1],D[MN&gt;&gt;1];int read()&#123; static int d;static char c; for(d=0,c=getchar();c&lt;'0'||c&gt;'9';c=getchar()); for(;c&gt;='0'&amp;&amp;c&lt;='9';d=(d&lt;&lt;3)+(d&lt;&lt;1)+c-'0',c=getchar()); return d;&#125;void add(int x,int y)&#123; for(;x&lt;=n;x+=lb(x))c[x]+=y;&#125;int qry(int x)&#123; int res=0; for(;x;x-=lb(x))res+=c[x]; return res;&#125;lg fac[MN],ifac[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void init()&#123; fac[0]=ifac[0]=1; for(int i=1;i&lt;MN;++i)&#123; fac[i]=fac[i-1]*i%lsk; ifac[i]=Pow(fac[i],lsk-2); &#125;&#125;lg C(int A,int B)&#123; return fac[A]*ifac[B]%lsk*ifac[A-B]%lsk;&#125;lg Q(int A,int B)&#123; return C(A,(A+B)/2);&#125;lg T(int A,int B)&#123; if(B&lt;0)return 0; return ((Q(A,B)-Q(A,B+2))%lsk+lsk)%lsk;&#125;int main()&#123; int TT;init(); scanf(\"%d\",&amp;TT); while(TT--)&#123; memset(D,0,sizeof D); memset(c,0,sizeof c); scanf(\"%d\",&amp;n);lg res=0; for(int i=1;i&lt;=n;++i)add(i,1); for(int i=1;i&lt;=n;++i)a[i]=read(); int mx=0,mn=1; for(int i=1;i&lt;n;++i)&#123; int g=max(mx,a[i]); int f=qry(g)+1; int d=n*2-(i-1)*2-f; res=(res+T(d,f))%lsk; D[a[i]]=1;add(a[i],-1); if(a[i]&gt;mx)mx=a[i]; else&#123; if(a[i]!=mn)break; &#125; while(D[mn])++mn; &#125; printf(\"%lld\\n\",res); &#125; return 0;&#125;","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://tenecnt.github.io/tags/组合数学/"},{"name":"NOI","slug":"NOI","permalink":"http://tenecnt.github.io/tags/NOI/"}]},{"title":"NOI2018归程(return)","slug":"noi18a","date":"2018-07-18T23:30:38.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/19/noi18a/","link":"","permalink":"http://tenecnt.github.io/2018/07/19/noi18a/","excerpt":"","text":"题面 在同步赛中，时间都花在T2上了，导致这题没怎么想，看到暴力+离线有75就马上打了，没有任何向标算上的思考，当然，可持久化并查集还是想到的，但是写…… 不过话说回来，写log^2的可持久化并查集的都过了…… 不过，标算是个神奇的东西，叫： 克鲁斯卡尔重构树～～其实这是个很蠢的东西～～大家都会克鲁斯卡尔最小生成树吧 只要在建树的时候，为新加的边新建一个点，并把别的两个点连它的儿子 这样，若干次的联通块就是若干子树了，只要倍增维护子树最小值就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define MN 800005#define lg long long#define pli pair&lt;lg,int&gt;#define mp make_pair#define ft first#define sd secondint n,m;int read()&#123; int d=0,f=1;char c=getchar(); while(c&gt;'9'||c&lt;'0')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;d=d*10+c-'0';c=getchar();&#125; return d*f;&#125;int nex[MN],tot=0,vi[MN],fr[MN],ai[MN];lg wi[MN];void add(int x,int y,lg z,int a)&#123; nex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;ai[tot]=a;&#125;struct Ege&#123; int x,y,a;lg c;&#125;E[MN];bool operator&lt;(Ege A,Ege B)&#123; return A.a&lt;B.a;&#125;struct Qry&#123; int v,p,id;&#125;Q[MN];bool operator&lt;(Qry A,Qry B)&#123; return A.p&lt;B.p;&#125;priority_queue&lt;pli,vector&lt;pli &gt;,greater&lt;pli &gt; &gt; pQ;lg ds[MN];int vis[MN],F[MN];lg V[MN];int L[MN];void djk()&#123; memset(ds,0x3f,sizeof ds); memset(vis,0,sizeof vis); ds[1]=0; while(!pQ.empty())pQ.pop(); pQ.push(mp(0,1)); while(!pQ.empty())&#123; int x=pQ.top().sd;pQ.pop(); if(vis[x])continue;vis[x]=1; for(int i=fr[x];i;i=nex[i])&#123; if(ds[x]+wi[i]&lt;ds[vi[i]])&#123; ds[vi[i]]=ds[x]+wi[i]; pQ.push(mp(ds[vi[i]],vi[i])); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)F[i]=i,V[i]=ds[i],L[i]=0x7f7f7f7f;&#125;int gf(int x)&#123; return F[x]==x?x:F[x]=gf(F[x]);&#125;lg res[MN];int f[20][MN];lg Lasans,Ans=0;void clean()&#123; tot=0;memset(fr,0,sizeof fr);Lasans=0;&#125;void un(int x,int y,int v)&#123; f[0][x]=++n; f[0][y]=n; V[n]=min(V[x],V[y]); L[n]=v; F[x]=F[y]=n;F[n]=n;&#125;void bt()&#123; sort(E+1,E+m+1); for(int i=m;i;--i)&#123; int fx=gf(E[i].x),fy=gf(E[i].y); if(fx!=fy)un(fx,fy,E[i].a); &#125; for(int i=1;i&lt;=19;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125;&#125;int main()&#123; int T=read(); while(T--)&#123; clean(); n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; int a=read(),b=read();lg c=read(),d=read(); add(a,b,c,d);add(b,a,c,d);E[i]=(Ege)&#123;a,b,d,c&#125;; &#125;int nn=n; djk();Lasans=0;bt(); int q=read(),K=read(),S=read(); for(int i=1;i&lt;=q;++i)&#123; int v=(read()+K*Lasans-1)%nn+1, p=(read()+K*Lasans)%(S+1); for(int j=19;~j;--j)if(L[f[j][v]]&gt;p)v=f[j][v]; Lasans=V[v]; printf(\"%lld\\n\",Lasans); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"},{"name":"NOI","slug":"NOI","permalink":"http://tenecnt.github.io/tags/NOI/"},{"name":"生成树","slug":"生成树","permalink":"http://tenecnt.github.io/tags/生成树/"}]},{"title":"多项式(2)","slug":"poly2","date":"2018-07-17T10:15:28.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/17/poly2/","link":"","permalink":"http://tenecnt.github.io/2018/07/17/poly2/","excerpt":"","text":"船新版本的多项式！加入了 开根\\large B(x)=\\cfrac{A(x)+B_0^2(x)}{2B_0(x)} 只有开根…… 不过这样一道6合一模板题(帕秋莉的超级多项式)还是少见的 卡常卡常卡常卡常 突然开了几个register就过了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN],Tmpsqrt[MN],Tmpsqrt2[MN];lg F[MN],G[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFTinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=wn*w%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d!=1)&#123; Inv(y,res,d+1&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFTinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;else&#123; res[0]=Pow(y[0],lsk-2); return; &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125;y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFTinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d!=1)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,d+1&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125;++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFTinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;else&#123; res[0]=1; return; &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Sqrt(lg *y,lg *res,int d)&#123; if(d!=1)&#123; int l=1&lt;&lt;((int)ceil(log2(1&lt;&lt;d))); Sqrt(y,res,(d+1)&gt;&gt;1); fill(Tmpsqrt,Tmpsqrt+l,0); Inv(res,Tmpsqrt,d); fill(Tmpsqrt+d,Tmpsqrt+l,0); copy(y,y+d,Tmpsqrt2); fill(Tmpsqrt2+d,Tmpsqrt2+l,0); FFTinit(l); dft(Tmpsqrt,l);dft(Tmpsqrt2,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]+Tmpsqrt[i]*Tmpsqrt2[i]%lsk; if(res[i]&gt;=lsk)res[i]-=lsk; &#125; idft(res,l); for(int i=0;i&lt;d;++i)&#123; res[i]=res[i]*inv[2]%lsk; &#125; fill(res+d,res+l,0); &#125;else&#123; res[0]=(lg)(sqrt(y[0])); &#125;&#125;void init()&#123; pw[0]=inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; &#125;&#125;int main()&#123; freopen(\"polynomial.in\",\"r\",stdin); freopen(\"polynomial.out\",\"w\",stdout); lg k; scanf(\"%d%lld\",&amp;n,&amp;k); init(); for(int i=0;i&lt;n;++i)scanf(\"%lld\",F+i); int l=1&lt;&lt;((int)ceil(log2(1&lt;&lt;n))); Sqrt(F,G,n); //for(int i=0;i&lt;n;++i)printf(\"%lld \",G[i]); fill(F,F+l,0); Inv(G,F,n); fill(G,G+l,0); Int(F,n); Exp(F,G,n); fill(F,F+l,0); Inv(G,F,n);++F[0]; fill(G,G+l,0); Ln(F,G,n);++G[0]; fill(F,F+l,0); Pow(G,F,n,k); Der(F,n); for(int i=0;i&lt;n;++i)printf(\"%lld \",F[i]); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"My Todolist和重要网站","slug":"todolist","date":"2018-07-16T05:09:41.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/16/todolist/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/todolist/","excerpt":"","text":"由于现实问题，todolist已被删除～～～～ 网站：谷歌代码规范","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://tenecnt.github.io/tags/规划/"}]},{"title":"多项式(1)","slug":"poly","date":"2018-07-16T04:46:48.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/16/poly/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/poly/","excerpt":"","text":"学习了一发多项式，感觉码风得到改善 包括了： 1. 求逆\\large B(x)=2B_0(x)-A(x)B_0^2(x)2. 求导xjb推即可 3. 积分xjb推即可 4. ln\\large \\begin{aligned}由： & H(x)=G(B(x))=B'(x)*G(B(x))\\\\ & H'(x)=G'(B(x))*B'(x)\\\\ 可得： & ln(B(x))=\\dfrac{1}{B(x)}*B'(x)\\end{aligned}5. exp\\large B(x)=B_0(x)*(1-ln(B_0(x))+A(x))6. pow\\large B(x)^k=e^{ln(B(x))\\times k}水果沙拉(CodeChef) 基本思路就是将k次方多项式展开，对每一项单独计算，可以推导出是若干以e为幂的数的和的乘积，然后就是多项式了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;bits/stdc++.h&gt;using namespace std;#define lg long long#define MN 1&lt;&lt;19|1#define lsk 998244353int n,k,l;lg pw[MN],inv[MN],rev[MN],Ex[MN],Iex[MN];lg Tmpinv[MN],Tmpln[MN],Tmpexp[MN],Tmppow[MN],Tmpfuc[MN];lg F[MN],G[MN],Res[MN];lg Pow(lg A,lg B)&#123; lg res=1; for(;B;B&gt;&gt;=1,A=A*A%lsk)if(B&amp;1)res=res*A%lsk; return res;&#125;void FFtinit(int l)&#123; for(int i=1;i&lt;l;++i)&#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1)); &#125;&#125;void dft(lg *y,int l)&#123; for(int i=1;i&lt;l;++i)&#123; if(i&lt;rev[i])swap(y[i],y[rev[i]]); &#125; for(int i=1;i&lt;l;i&lt;&lt;=1)&#123; lg wn=pw[i]; for(int j=0;j&lt;l;j+=i*2)&#123; lg w=1; for(int k=j;k&lt;i+j;++k)&#123; lg F=y[k+i]*w%lsk,T=y[k]; y[k]=(F+T)%lsk; y[k+i]=(T-F)%lsk; if(y[k+i]&lt;0)y[k+i]+=lsk; w=w*wn%lsk; &#125; &#125; &#125;&#125;void idft(lg *y,int l)&#123; reverse(y+1,y+l); dft(y,l);lg INv=Pow(l,lsk-2); for(int i=0;i&lt;l;++i)&#123; y[i]=y[i]*INv%lsk; &#125;&#125;void Inv(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=Pow(y[0],lsk-2); return; &#125;else&#123; Inv(y,res,(d+1)&gt;&gt;1); int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,Tmpinv); fill(Tmpinv+d,Tmpinv+l,0); FFtinit(l); dft(Tmpinv,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=((2-Tmpinv[i]*res[i])%lsk+lsk)*res[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Der(lg *y,int d)&#123; for(int i=0;i&lt;d-1;++i)&#123; y[i]=y[i+1]*(i+1)%lsk; &#125; y[d-1]=0;&#125;void Int(lg *y,int d)&#123; for(int i=d-1;i;--i)&#123; y[i]=y[i-1]*inv[i]%lsk; &#125;y[0]=0;&#125;void Ln(lg *y,lg *res,int d)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); copy(y,y+d,res); fill(res+d,res+l,0); Der(res,d); fill(Tmpln,Tmpln+l,0); Inv(y,Tmpln,d);FFtinit(l); dft(Tmpln,l);dft(res,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpln[i]%lsk; &#125; idft(res,l); Int(res,d); fill(res+d,res+l,0);&#125;void Exp(lg *y,lg *res,int d)&#123; if(d==1)&#123; res[0]=1; return; &#125;else&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); Exp(y,res,(d+1)&gt;&gt;1); fill(Tmpexp,Tmpexp+l,0); Ln(res,Tmpexp,d); for(int i=0;i&lt;d;++i)&#123; Tmpexp[i]=y[i]-Tmpexp[i]; if(Tmpexp[i]&lt;0)Tmpexp[i]+=lsk; &#125; ++Tmpexp[0]; if(Tmpexp[0]&gt;=lsk)Tmpexp[0]-=lsk; FFtinit(l); dft(res,l);dft(Tmpexp,l); for(int i=0;i&lt;l;++i)&#123; res[i]=res[i]*Tmpexp[i]%lsk; &#125; idft(res,l); fill(res+d,res+l,0); &#125;&#125;void Pow(lg *y,lg *res,int d,lg k)&#123; int l=1&lt;&lt;((int)ceil(log2(d&lt;&lt;1))); fill(Tmppow,Tmppow+d,0); Ln(y,Tmppow,d);k%=lsk; for(int i=0;i&lt;l;++i)Tmppow[i]=Tmppow[i]*k%lsk; Exp(Tmppow,res,d); fill(res+d,res+l,0);&#125;void Func(lg u,lg *res)&#123; Tmpfuc[1]=u+1; Tmpfuc[0]=0; int l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); fill(res,res+l,0); Exp(Tmpfuc,res,k+2); for(int i=0;i&lt;=k;++i)res[i]=res[i+1]; res[k+1]=0; fill(res+k+1,res+l,0); FFtinit(l); dft(res,l); for(int i=0;i&lt;=l;++i)&#123; res[i]=res[i]*Iex[i]%lsk; &#125; idft(res,l); fill(res+k+1,res+l,0); fill(Tmpfuc,Tmpfuc+l,0);&#125;void init()&#123; l=1&lt;&lt;((int)ceil(log2((k+1)&lt;&lt;1))); pw[0]=1;inv[0]=inv[1]=1; for(int i=2;i&lt;=1&lt;&lt;19;++i)&#123; pw[i]=Pow(3,(lsk-1)/i/2); inv[i]=inv[lsk%i]*(lsk-lsk/i)%lsk; assert(inv[i]); &#125; Ex[0]=1; for(int i=1;i&lt;=k;++i)&#123; Ex[i]=Ex[i-1]*inv[i+1]%lsk; &#125; Inv(Ex,Iex,k+1); FFtinit(l); dft(Iex,l);&#125;int main()&#123; scanf(\"%d%*d%d\",&amp;k,&amp;n); init(); fill(Res,Res+l,0);Res[0]=1; for(int i=1;i&lt;=n;++i)&#123; lg a,b;int c; scanf(\"%lld%lld%d\",&amp;a,&amp;b,&amp;c); fill(G,G+k+1,0); fill(F,F+k+1,0); Func(b,G);Func(a-1,F); for(int j=0;j&lt;=k;++j)&#123; G[j]-=F[j]; if(G[j]&lt;0)G[j]+=lsk; &#125; fill(F,F+k+1,0); Pow(G,F,k+1,c); FFtinit(l); dft(Res,l);dft(F,l); for(int j=0;j&lt;l;++j)&#123; Res[j]=Res[j]*F[j]%lsk; &#125; idft(Res,l); fill(Res+k+1,Res+l,0); &#125; lg res=1; for(int i=2;i&lt;=k;++i)res=res*i%lsk; printf(\"%lld\",res*Res[k]%lsk); return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"http://tenecnt.github.io/tags/多项式/"}]},{"title":"后缀自动机","slug":"hzzdj","date":"2018-07-15T18:26:05.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/16/hzzdj/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/hzzdj/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738char c[MN];int n,tot=0;struct Node&#123; int maxlen,slink,tran[26];&#125;N[MN];int Nd(int _maxlen,int _tran,int _slink)&#123; N[++tot]=(Node)&#123;_maxlen,_slink,0&#125;; if(_tran)&#123; for(int i=0;i&lt;26;++i)if(N[_tran].tran[i])N[tot].tran[i]=N[_tran].tran[i];else N[tot].tran[i]=0; &#125;else for(int i=0;i&lt;26;++i)N[tot].tran[i]=0; return tot;&#125;int addchar(char cc,int u)&#123; int ch=cc-'a'; int z=Nd(N[u].maxlen+1,0,0); int v=u; while(v&amp;&amp;!N[v].tran[ch])&#123; N[v].tran[ch]=z; v=N[v].slink; &#125; if(!v)&#123;N[z].slink=1;return z;&#125; int x=N[v].tran[ch]; if(N[v].maxlen==N[x].maxlen-1)&#123; N[z].slink=x; return z; &#125; int y=Nd(N[v].maxlen+1,x,N[x].slink); N[x].slink=y;N[z].slink=y; while(v&amp;&amp;N[v].tran[ch]==x)&#123; N[v].tran[ch]=y; v=N[v].slink; &#125;return z;&#125;void insert()&#123; Nd(0,0,0); int now=1; for(int i=1;i&lt;=n;++i)&#123;now=addchar(c[i],now);&#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://tenecnt.github.io/tags/字符串/"}]},{"title":"虚树","slug":"xushu","date":"2018-07-15T18:21:10.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/16/xushu/","link":"","permalink":"http://tenecnt.github.io/2018/07/16/xushu/","excerpt":"","text":"转移重要代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define MN 600005#define pil pair&lt;int,long long&gt;#define mp make_pair#define ft first#define sd second#define lg long longint n,m,K,q;int nex[MN],fr[MN],vi[MN];lg wi[MN];int tote;int tail=0,stk[MN];void add(int x,int y,lg z)&#123; nex[++tote]=fr[x];fr[x]=tote;wi[tote]=z;vi[tote]=y;&#125;int dfc=0,dfn[MN];int dep[MN],f[20][MN];lg g[20][MN];void dfs(int x,int fa)&#123; dfn[x]=++dfc;for(int i=1;i&lt;=19;++i)f[i][x]=f[i-1][f[i-1][x]],g[i][x]=min(g[i-1][x],g[i-1][f[i-1][x]]); for(int i=fr[x];i;i=nex[i])if(vi[i]!=fa)&#123; f[0][vi[i]]=x;g[0][vi[i]]=wi[i];dep[vi[i]]=dep[x]+1;dfs(vi[i],x); &#125;&#125;pil Lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); if(x==y)return mp(x,0); lg res=0x3f3f3f3f3f3f3f3f; for(int i=19;~i;--i)&#123; if(dep[f[i][x]]&gt;=dep[y])&#123; res=min(res,g[i][x]); x=f[i][x]; &#125; &#125;if(x==y) return mp(x,res); for(int i=19;~i;--i)&#123; if(f[i][x]!=f[i][y])&#123; res=min(res,min(g[i][x],g[i][y])); x=f[i][x];y=f[i][y]; &#125; &#125; return mp(f[0][x],min(res,min(g[0][x],g[0][y])));&#125;int v[MN],dd[MN];int Fr[MN],Nex[MN],Vi[MN];lg Wi[MN];int Tot=0;queue&lt;int&gt; Q;void Add(int x,int y,lg z)&#123;Nex[++Tot]=Fr[x];Wi[Tot]=z;Fr[x]=Tot;Vi[Tot]=y;Nex[++Tot]=Fr[y];Wi[Tot]=z;Fr[y]=Tot;Vi[Tot]=x;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;lg dfs2(int x,int fa)&#123; lg ans=0; // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;fa&lt;&lt;endl; for(int i=Fr[x];i;i=Nex[i])if(Vi[i]!=fa)&#123; // cout&lt;&lt;Vi[i]&lt;&lt;endl; if(dd[Vi[i]])ans+=Wi[i];else ans+=min(Wi[i],dfs2(Vi[i],x)); &#125;return ans;&#125;void bt()&#123; sort(v+1,v+m+1,cmp);Tot=0;pil L;tail=0; for(int i=0;i&lt;=m;++i)dd[v[i]]=1; // cout&lt;&lt;\"&amp;\"&lt;&lt;endl; for(int i=0;i&lt;=m;++i)&#123; // cout&lt;&lt;i&lt;&lt;endl; if(i&amp;&amp;v[i]==v[i-1])continue; // cout&lt;&lt;v[i]&lt;&lt;' '&lt;&lt;v[i-1]&lt;&lt;endl; L=Lca(stk[tail],v[i]);; while(tail&gt;1)&#123; if(dep[L.ft]&gt;dep[stk[tail]]||L.ft==stk[tail])break; // cout&lt;&lt;stk[tail]&lt;&lt;' '&lt;&lt;stk[tail-1]&lt;&lt;' '&lt;&lt;Lca(stk[tail],stk[tail-1]).sd&lt;&lt;\"&amp;&amp;&amp;\"&lt;&lt;endl; Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd); --tail; &#125; if(L.ft!=stk[tail])Fr[L.ft]=0,stk[++tail]=L.ft,Q.push(L.ft); for(int i=0;i&lt;=m;++i)dd[v[i]]=0; Fr[v[i]]=0;stk[++tail]=v[i];Q.push(v[i]); &#125; // cout&lt;&lt;\"@\"&lt;&lt;endl; while(tail!=1)Add(stk[tail],stk[tail-1],Lca(stk[tail],stk[tail-1]).sd),--tail; printf(\"%lld\\n\",dfs2(1,1)); while(!Q.empty())&#123;int x=Q.front();Q.pop();dd[x]=0;&#125; // cout&lt;&lt;\"^\"&lt;&lt;endl;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1,x,y;i&lt;n;++i)&#123; lg z; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); &#125;dep[1]=1;dfs(1,1); scanf(\"%d\",&amp;q);v[0]=1; while(q--)&#123; // cout&lt;&lt;\"$\"&lt;&lt;endl; scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;++i)scanf(\"%d\",v+i); bt(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://tenecnt.github.io/tags/图论/"}]},{"title":"Helloworld","slug":"Helloworld","date":"2018-07-14T00:19:15.000Z","updated":"2018-09-12T05:30:32.874Z","comments":true,"path":"2018/07/14/Helloworld/","link":"","permalink":"http://tenecnt.github.io/2018/07/14/Helloworld/","excerpt":"","text":"第二次转移博客$ \\sqrt{\\phi} $ {1+1=2}{\\fac 1}Simple inline $ a = b + c $ \\frac{\\partial u}{\\partial t} = h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)","categories":[],"tags":[{"name":"试验","slug":"试验","permalink":"http://tenecnt.github.io/tags/试验/"},{"name":"math","slug":"math","permalink":"http://tenecnt.github.io/tags/math/"}]}]}